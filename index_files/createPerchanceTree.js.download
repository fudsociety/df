// Heads up: This code is extremely messy and hacked together. Certain parts are
// hilariously bad, especially the Proxy stuff. A version 2 is definitely in order,
// but I probably won't have time to do that for quite a while. -Joe

let NODE_ODDS_INDICATOR_CHARACTER = "^";

window.__rootProxyHasHandler; // <-- gets set after rootProxy creation
window.__rootProxyHasHandler_Greedy = function(target, prop) {
  if(prop in window) {
    if(prop in this.executeChain(target, this.capturedCalls)) {
      return true;
    } else {
      return false; // don't be so greedy that we steal window's props even when `window` has it and `root` doesn't.
    }
  } else {
    return true;
  }
}

// window.globalProxyLoopCount = 0;
// function proxyLoopCountResetLoop() {
//   window.globalProxyLoopCount = 0;
//   setTimeout(proxyLoopCountResetLoop, 1000);
// }
// proxyLoopCountResetLoop();

function __createPerchanceTree(text, moduleName, backupModuleName /*<-- this is for the hacky node creation function*/, doNotPreprocess) {

  const functionStartTime = Date.now();

  /*
    There are two main steps in creating the tree:
    1. We split up the text into lines and collect all the data we need about each line (e.g. odds, line number, etc.) and tidy it up as necessary (e.g. .trim() it, or remove it completely if it's a comment). Then we group sets of lines that are below a function header into said function header. We create all the parent/child hierarchy links along the way.
    2. We turn all that node data into a neat "perchance tree" which has the properties required to make the DSL work nicely, and we attach all the perchance methods to each node. Then we return the root node in this tree.
  */

  // remove inline comments
  let lines = text.replace(/\r/g,"").split("\n");
  const commentRegex = /\/\//;
  for(let i = 0; i < lines.length; i++) {
    if(!commentRegex.test(lines[i])) continue; // <-- just an optimisation
    lines[i] = __stripCommentFromLine(lines[i]);
  }

  // trim EMPTY lines (otherwise whitespace can throw indentation error in next step)
  // we need to keep blank lines so line numbers are preserved. they're removed in a bit
  lines = lines.map(text => /[^\s]/.test(text) ? text : text.trim());

  // mixed spaces and tabs -> only tabs
  for(let i = 0; i < lines.length; i++) {
    let normed = __normaliseLineIndentsToTabs(lines[i]);
    if(normed === false) {
      __perchanceError(`There appears to be an indenting error on this line near this text: "${__escapeHTMLSpecialChars(lines[i].substr(0,30))}". Perchance lists should be indented with either one tab or two spaces. If you want to have a space before a list item, then you should start the item with "\\s" (backslash + "s") which will be converted into a space (you can read more about this in the <a href="/tutorial">tutorial</a>).`, i+1);
      return;
    } else {
      lines[i] = normed;
    }
  }

  // make lines objects
  for(let i = 0; i < lines.length; i++) {
    lines[i] = {
      text: lines[i],
      indents: lines[i].search(/[^\t]/), //index of first non-tab
      lineNumber:i+1, // plus one because line num start at 1 by convention
      children:[],
      parent: null,
      // REMEMBER: if you add anything here you need to add it to root line bject and line objects created in inline declarations
    }
    lines[i].text = lines[i].text.trim(); //trim away indents and end whitespace
  }

  // remove blank lines
  lines = lines.filter(l => l.text !== "");

  // create parent-child hierarchy
  let root = {
    text:"<root>",
    indents:-1,
    lineNumber:-1,
    children:[],
    parent: null,
    nodeType: "text",
    odds: "1",
    perchanceCode:"",
    //expressionArray: ["<root>"],
  };
  let indentOwners = {0:root}; // maps # indents of current line to correct parent
  for(let i = 0; i < lines.length; i++) {
    let line = lines[i];
    let indents = line.indents;
    if(indentOwners[indents]) {
      // this is child of indentOwners[indents]:
      indentOwners[indents].children.push(line);
      line.parent = indentOwners[indents];
      // this becomes owner of next indent level:
      indentOwners[indents+1] = line;
      // and *no one* owns the indent level after that:
      indentOwners[indents+2] = undefined;
    } else {
      __perchanceError(`There appears to be an indenting error on this line near this text: "${__escapeHTMLSpecialChars(line.text.substr(0,30))}". Perchance lists should be indented with either one tab or two spaces. If you want to have a space before a list item, then you should start the item with "\\s" (backslash + "s") which will be converted into a space (you can read more about this in the <a href="/tutorial">tutorial</a>).`, line.lineNumber);
      return;
    }
  }

  // for each node, get the perchance text required to create it:
  for(let i = 0; i < lines.length; i++) {
    lines[i].perchanceCode = lines[i].text;
    let j = 0;
    let parent = lines[i].parent;
    let ancestor = parent;
    while(1) {

      if(ancestor.parent === null) ancestor.perchanceCode += `${ancestor.perchanceCode ? "\n" : ""}` + lines[i].text; // handle case where ancestor === root node
      else ancestor.perchanceCode += "\n" + "  ".repeat(lines[i].indents - ancestor.indents) + lines[i].text;

      ancestor = ancestor.parent;
      if(!ancestor) break;

      if(j++ > 100000) {
        __perchanceError(`Some sort of looping/recursion error has occurred. Please make a post on the subreddit (reddit.com/r/perchance) so I can take a look at this. Thanks!`);
        return;
      }

    }
  }
  root.perchanceCode = text;

  // check for variable names wrapped in square brackets when they're already within a square block:
  const unnecessarySquareBracketsRegex = /([^\\]|^)\[([^\]]*?[^a-zA-Z_$\]]|)\[[a-zA-Z_$.]+?\][^\]]*?\]/;
  // above regex explained:
  //  - we need the [^a-zA-Z_$\]] part (character right before inner square brackets must not be a variable-name character) because we don't want to show a warning for `[myList[key]]`, for example.
  //  - we need the dot in [a-zA-Z_$.]+ because we of course want to be able to detect and warn about something like `[a > 7 ? [list.subProp] : "blah"]`
  //  - this doesn't handle escaping properly (because the preceding backslash could itself be escaped), and doesn't properly handle the fact that square brackets could occur within strings/regex/etc. that are within the outer square block
  const singleEqualsInDynamicOddsRegex = /\^\[[^\]]*[^=!<>]=[^=][^\]]*\]\s*$/;
  const singleEqualsInIfElseConditionRegex = /\[if\s*\([^\)]*[^=]=[^=][^\)]*\)\s*\{/;
  for(let i = 0; i < lines.length; i++) {
    if(lines[i].text.length > 5000) continue;
    if(lines[i].text.indexOf("[") === -1) continue; // <-- just an optimisation

    // unnecessary square brackets:
    if(lines[i].text.indexOf("\"") !== -1) {
      // remove double-quoted parts (very hacky, but it's not a huuge deal if it causes us to miss some - it's better than false positives):
      let newText = lines[i].text.replace(/".*?"/g, `""`);
      if(newText.match(unnecessarySquareBracketsRegex)) { // don't use .test() --> https://stackoverflow.com/a/21373261/11950764
        window.codeWarningsArray.push({lineNumber:lines[i].lineNumber, generatorName:moduleName, warningId:"square-brackets-wrapping-variable-name-within-square-block"});
      }
    } else {
      if(lines[i].text.match(unnecessarySquareBracketsRegex)) {
        window.codeWarningsArray.push({lineNumber:lines[i].lineNumber, generatorName:moduleName, warningId:"square-brackets-wrapping-variable-name-within-square-block"});
      }
    }
    
    if(lines[i].text.match(singleEqualsInIfElseConditionRegex)) {
      window.codeWarningsArray.push({lineNumber:lines[i].lineNumber, generatorName:moduleName, warningId:"single-equals-in-if-else-condition"});
    }

    // single equals in dynamic odds
    if(lines[i].text.indexOf("^[") === -1) continue; // <-- just an optimisation
    if(lines[i].text.match(singleEqualsInDynamicOddsRegex)) {
      window.codeWarningsArray.push({lineNumber:lines[i].lineNumber, generatorName:moduleName, warningId:"single-equals-in-dynamic-odds"});
    }
  }

  // get node data for functions (pack all details into header node and remove children)
  // note that we need to handle functions first because otherwise lines of js will be
  // classed as other node types
  for(let i = 0; i < lines.length; i++) {
    let funcHeaderDetails = __getFunctionHeaderDetails(lines[i].text);
    if(funcHeaderDetails) {
      lines[i].nodeType = "function";

      lines[i].functionName = funcHeaderDetails.name;
      lines[i].functionArgs = funcHeaderDetails.args; // <-- array of arg names
      // recursively collect all children, grandchildren, etc into one flat array:
      let children = lines[i].children;
      let j = 0;
      while(1) {
        if(j >= children.length) { break; }
        let c = children[j];
        children.splice(j+1, 0, ...c.children); // must put them in correct pos
        j++;
      }
      // remove children/grandchildren/... from lines array:
      for(let c of children) {
        lines = lines.filter(l => l !== c);
      }
      // concat children/grandchildren/... with newlines and add to functionBody property
      lines[i].functionBody = children.map(l => l.text).join("\n");
      // remove children
      lines[i].children = [];
    }
  }

  // get node data for inline functions
  const functionNodeRegex = /=>/;
  for(let i = 0; i < lines.length; i++) {
    if(lines[i].nodeType) continue;
    if(!functionNodeRegex.test(lines[i].text)) continue; // <-- just an optimisation
    let inlineFuncDetails = __getInlineFunctionDetails(lines[i].text);
    if(inlineFuncDetails) {
      lines[i].nodeType = "function";

      // inline functions shouldn't have children
      if(lines[i].children.length > 0) {
        __perchanceError(`It appears that you've tried to give an inline function children (child items). At this point, inline functions are not allowed to have children (though I could change this in the future if people need this feature). There's also the possibility that you accidentally created an inline function. Inline functions have the form: <b>functionName(input1, input2, ...) =&gt; functionBody</b>. If you'd like to use "=" in a literal sense, put a backslash character right before it like this: "\\=".`, lines[i].lineNumber);
        return;
      }

      lines[i].functionName = inlineFuncDetails.name;
      lines[i].functionArgs = inlineFuncDetails.args; // <-- array of arg names
      lines[i].functionBody = inlineFuncDetails.body;
    }
  }


  // TODO: process other node-types (list with args) here

  const primitiveNodeRegex = /=/;
  for(let i = 0; i < lines.length; i++) {
    if(lines[i].nodeType) continue;
    if(!primitiveNodeRegex.test(lines[i].text)) continue; // <-- just an optimisation

    let details = __getPrimitiveNodeDetails(lines[i].text);
    if(details) {
      // NOTE: We've discovered an inline/"primitive" thing, but here's the thing:
      //       If it's not a direct reference (i.e. value !== "[...]" or "{...}")
      //       but it DOES contain square/curly block(s), then we need to make it
      //       into a normal node with details.value as a child.
      //       See marker odj29hfi3j0d2kj0hx24f for the handling of $value nodes.
      //       The reason we need to do this is because if we had ``output = [prefix]-blah` (for example)
      //       then we couldn't call `output.selectMany(3)` on it if it was a $value node.
      //       Basically, the fact that I want to be able to create "direct references" with
      //       value nodes means a bunch of mucking around trying to make everything else work
      //       as expected.
      // let blocks = splitTextAtAllBlocks(details.value);
      // if(blocks.length > 1) {
      //   lines[i].nodeType = "text";
      //   lines[i].text = details.key;
      //   //lines[i].expressionArray = [details.key];
      //   let child = {
      //     text: details.value,
      //     indents: lines[i].indents+1,
      //     lineNumber:lines[i].lineNumber,
      //     children:[],
      //     parent: lines[i],
      //     nodeType:"text",
      //     odds:"1",
      //     //expressionArray: splitTextAtSquareBlocks(details.value),
      //   }
      //   lines[i].children.push(child);
      //   lines.splice(i+1, 0, child);
      // } else {
        lines[i].nodeType = "primitiveKeyValue";
        lines[i].primitiveKey = details.key;
        lines[i].primitiveValue = details.value;
        if(details.key.trim().includes(" ")) {
          window.codeWarningsArray.push({lineNumber:lines[i].lineNumber, generatorName:moduleName, warningId:"unescaped-equals-sign"});
        }
      //}
    }

  }

  // extract all the node data (odds, expression array) for plain old text nodes
  const oddsDetailsRegex = /\^/;
  for(let i = 0; i < lines.length; i++) {
    if(lines[i].nodeType) continue;
    if(!oddsDetailsRegex.test(lines[i].text)) { // <-- just an optimisation
      lines[i].odds = "1";  // as string because all the others are strings - system is built to take strings and interpret them as expresions/numbers
    } else {
      // extract and remove odds stuff first:
      let oddsDetails = __getTextOddsDetails(lines[i].text);
      let odds, textWithoutOdds;
      if(oddsDetails) {
        lines[i].nodeType = "text";
        lines[i].odds = oddsDetails.odds;
        lines[i].text = oddsDetails.textWithoutOdds.trim(); // <-- NOTE: spaces between end of text and odds notation are ignored in lists! thus we trim. (not in curly "or" blocks though)
      } else {
        lines[i].odds = "1"; // as string because all the others are strings - system is built to take strings and interpret them as expresions/numbers
      }
    }

    lines[i].nodeType = "text";
    // let arr = splitTextAtSquareBlocks(lines[i].text);
    // if(arr) {
    //   lines[i].nodeType = "text";
    //   lines[i].expressionArray = arr;
    //   // if((lines[i].expressionArray.length > 1 || (lines[i].expressionArray.length === 1 && lines[i].expressionArray[0][0] === "[")) && lines[i].children.length > 0) {
    //   //   console.error(`Error on line number ${lines[i].lineNumber}. Lines with random variables shouldn't have children.`);
    //   //   return;
    //   // }
    // }

    // if(oddsDetails && !arr) {
    //   perchanceError(`It seems that you've got a '^' character where it shouldn't be. The '^' character is a special one that allows you to specify how likely a node is of being selected. This "odds notation" should not be present on functions or other non-text nodes because they aren't a part of the group which is randomly selected from (they are special children). If you want to use the odds character ("^") literally (i.e. not to declare likelihood), then you can put a backslash character before it like so: \\^`, lines[i].lineNumber);
    //   return;
    // }

  }

  // // warn for unclassified lines and then set nodeType as "text"
  // for(let i = 0; i < lines.length; i++) {
  //   if(!lines[i].nodeType) {
  //     perchanceError(`For some reason this line could not be classified properly. There may be something wrong with your syntax of this line, or it may be a bug with the Perchance engine. If you think that there's a bug, please report it here: <a href="http://reddit.com/r/perchance">reddit.com/r/perchance</a>. That would be very much appreciated! :)`, lines[i].lineNumber);
  //     lines[i].nodeType = "text";
  //     lines[i].expressionArray = [lines[i].text];
  //   }
  // }


  // next up, construct the actual perchance node tree.
  // first create a node for each line
  // then connect up parent/children
  //
  // we also the perchance methods including the .toString() function to each node.
  // the toString function is where the magic happens. calling
  // [myrootvar] will just return the myrootvar variable. when this
  // gets joined to a string, `myrootvar.toString()` is called which
  // recursively resolves it into an actual string value, taking into
  // account odds and other expressions (in expressionArrays) that it
  // finds along the way


  // 1. convert lines to perchance nodes
  let allNodes = [];
  lines.unshift(root);
  for(let i = 0; i < lines.length; i++) {

    lines[i].node = {};

    lines[i].node[Symbol.for("node data")] = { // TODO: why use symbol? just put it in a non-enumerable $data property? then fix up all references to it? TODO: can this be deleted after we're done creating tree?
      parentNode:null,
      childNodes:[],
      root:root,
      declarationLineNumber: lines[i].lineNumber,
      odds: null,
    };

    // make default function properties writable (not needed because we use simple objects now)
    // Object.defineProperty(lines[i].node, "name", {writable:true});
    // Object.defineProperty(lines[i].node, "length", {writable:true});

    // NOTE TO SELF: Object.defineProperty seems to cause some bad performance slow-downs, but I'm pretty sure
    // we need to make these properties non-enumerable - at least, I think that was the original idea. Might be worth
    // thinking about this at some point because the perf gains are definitely significant if you can somehow avoid defineProperty.

    Object.defineProperty(lines[i].node, "$root", {value:root.node, writable:true, configurable:true});
    Object.defineProperty(lines[i].node, "$declarationLineNumber", {value:lines[i].lineNumber, writable:true, configurable:true});
    Object.defineProperty(lines[i].node, "$moduleName", {value:moduleName, writable:true, configurable:true});
    Object.defineProperty(lines[i].node, Symbol.toPrimitive, {value:function(hint) {
      return this.valueOf();
      // if(hint === "default" || hint === "string") {
      //   return this.toString();
      // } else {
      //   return this.valueOf();
      // }
    }, writable:true, configurable:true});

    // add $valueChildren array which contains all children of type 'value' so we can get the "properties" of a node (for stuff like 'generateInstance' plugin or build-in feature)
    Object.defineProperty(lines[i].node, "$valueChildren", {value:[], writable:true, configurable:true});

    // this is used in isFunctionNode in the proxy stuff:
    Object.defineProperty(lines[i].node, "$functionChildren", {value:[], writable:true, configurable:true});

    Object.defineProperty(lines[i].node, "$perchanceCode", {value:lines[i].perchanceCode, writable:true, configurable:true});

    __addNodeMethods(lines[i].node);

    allNodes.push(lines[i].node);

  }

  // 2. fill in parent/child references:
  for(let i = 0; i < lines.length; i++) {
    let node = lines[i].node;
    let nodeData = node[Symbol.for("node data")];
    if(i === 0) { // i.e. if root - (since root has no parent)
      nodeData.parentNode = null;
      Object.defineProperty(node, "$parent", {value:null, writable:true, configurable:true});
    } else {
      nodeData.parentNode = lines[i].parent.node;
      Object.defineProperty(node, "$parent", {value:lines[i].parent.node, writable:true, configurable:true}); // <-- give it a public reference to its parent that *isn't* enumerable
    }
    nodeData.childNodes = lines[i].children.map(line => line.node);
  }

  // 3. fill in the rest of the node details depending on the node type
  for(let i = 0; i < lines.length; i++) {
    let node = lines[i].node;
    let nodeData = lines[i].node[Symbol.for("node data")];

    // add normal text nodes
    if(lines[i].nodeType === "text") {
      nodeData.type = "text";
      nodeData.odds = lines[i].odds;
      //nodeData.expressionArray = lines[i].expressionArray;

      Object.defineProperty(lines[i].node, "$nodeType", {value:"normal", writable:true, configurable:true});
      Object.defineProperty(lines[i].node, "$oddsText", {value:lines[i].odds, writable:true, configurable:true});

      Object.defineProperty(lines[i].node, "$text", {value:lines[i].text, writable:true, configurable:true}); // <-- give it a public reference to its text that *isn't* enumerable
      if(node.$parent) { // i.e. if not root
        let key = node.$text;
        while(node.$parent[key] !== undefined) {// if there's already one called this, add {|} (hacky, but I think it's fine since they're just text nodes?)
          key += "{|}";
        }
        node.$parent[key] = node; // not via defineProperty, therefore it's enumerable
      }

    }

    // add user-defined functions
    if(lines[i].nodeType === "function") {
      nodeData.type = "function";
      nodeData.functionName = lines[i].functionName;
      nodeData.functionArgs = lines[i].functionArgs;
      nodeData.functionBody = lines[i].functionBody;
      //let withStr = `window.root.$imports.includes("${moduleName}") ? window.root.$imports[window.root.$imports.indexOf("${moduleName}")] : window.root`;
      let moduleRefStr = `window.moduleSpace["${moduleName || backupModuleName}"]`;
      let finalFunctionBody = `
        let tempHasHandlerRememberer927394 = ${moduleRefStr}.___proxyHandler.has;
        ${moduleRefStr}.___proxyHandler.has = window.__rootProxyHasHandler; /* .bind(${moduleRefStr}.___proxyHandler); */


        ${nodeData.functionArgs.map(a => __isValidJavaScriptIdentifier(a) ? `if(${a} && ${a}.getSelf) ${a} = ${a}.getSelf;` : '').join("")}

        // make a proxy for the module so we can "exclude" this function's inputs from the "with" statement.
        // this allows us to have inputs that are the same name as module globals and they won't be "overwritten" by those globals.
        // I had to add the Number stuff because my numbers were acting funny after messing with their prototype: https://stackoverflow.com/questions/52580398/why-doesnt-new-arraynew-number3-produce-an-array-of-length-3  (edit: originally had just !isNaN(a), but I had to add the toPrecision and $nodeType type stuff because isNaN was executing valueOf on list objects/nodes, which obviously causes trouble)
        let moduleRefProxy = new Proxy(${moduleRefStr}.___proxyTarget.obj, {
          get: function(target, name) {
            if(false) {} // <-- just to make the next line easier to write
            ${nodeData.functionArgs.map(a => { a = a.split("=")[0]; if(a.startsWith("...")) { a = a.slice(3); } return `else if (name === "${a}") { return typeof ${a} !== "object" && !${a}.$nodeType && ${a}.toPrecision && ${a}.toExponential && !isNaN(${a}) ? Number(${a}) : ${a}; }` }).join("\n")}
            /*else if (name === "b") { return 10; }*/
            else { return target[name]; }
          }
        });

        let returnValue;
        with(moduleRefProxy) {
          let root = ${moduleRefStr}.___proxyTarget.obj; // <-- because for some reason 'root' was referencing window.root (which is different to this modules root if this is an imported module) 💕
          returnValue = (function(${nodeData.functionArgs.join(",")}) {
            ${nodeData.functionBody}
          }).apply(this, [${nodeData.functionArgs.join(",")}]);
        }

        ${moduleRefStr}.___proxyHandler.has = tempHasHandlerRememberer927394;
        return returnValue;
      `;
      nodeData.functionRef = new Function(nodeData.functionArgs.join(","), finalFunctionBody).bind(nodeData.parentNode);
      //nodeData.parentNode[nodeData.functionName] = new Function(nodeData.functionArgs.join(","), nodeData.functionBody).bind(nodeData.parentNode);
      Object.defineProperty(lines[i].node, "$nodeType", {value:"function", writable:true, configurable:true});
      Object.defineProperty(nodeData.parentNode, nodeData.functionName, {value:nodeData.functionRef, writable:true, configurable:true});
      Object.defineProperty(lines[i].node, "$text", {value:nodeData.functionName, writable:true, configurable:true});
      Object.defineProperty(lines[i].node, "$function", {value:nodeData.functionRef, writable:true, configurable:true});

      nodeData.parentNode.$functionChildren.push(lines[i].functionName);

    }

    if(lines[i].nodeType === "primitiveKeyValue") {
      nodeData.type = "primitiveKeyValue";
      nodeData.primitiveKey = lines[i].primitiveKey;
      nodeData.primitiveValue = lines[i].primitiveValue;
      // NOTE: it appears that then we write "[apple*10]" where apple={1|2|3}, JS implicitely calls toString on apple (even though it's a multiplication operation). so we don't need to worry about implementing valueOf
      //node.$value = lines[i].primitiveValue;
      //node.$key = lines[i].primitiveKey;
      let value = lines[i].primitiveValue;

      // if it's just plain text, process escaped characters (remove backslashes)
      // EDIT: NO! That's a terrible idea. Why remove escaped characters?! If you do, `output = \[wassup\]` throws an error (obviously). Was there a reason I previously thought this was a good idea?
      if(typeof value === 'string') {
        let split = __splitTextAtAllBlocks(value);
        if(typeof value === 'string' && split.length === 1 && split[0][0] !== "[" && split[0][0] !== "{") { // only need to check start bracket because it it exists, then it is unescaped, then the last character *must* be a closing bracket (since splitted text array has length of 1) else the first bracket would be unclosed
          //value = processEscapedCharacters(value);
          Object.defineProperty(lines[i].node, "$isPlainPrimitive", {value:true, writable:true, configurable:true});
        }
      } else if(typeof value === "number" || typeof value === "boolean") {
        Object.defineProperty(lines[i].node, "$isPlainPrimitive", {value:true, writable:true, configurable:true});
      } else {
        throw new Error("unknown primitive type??");
      }

      Object.defineProperty(lines[i].node, "$value", {value:value, writable:true, configurable:true});
      Object.defineProperty(lines[i].node, "$key", {value:lines[i].primitiveKey, writable:true, configurable:true});
      //Object.defineProperty(nodeData.parentNode, lines[i].primitiveKey, {value:node, writable:true, configurable:true});

      // Just to be helpful:
      if(typeof nodeData.primitiveValue === "string" && nodeData.parentNode === nodeData.root.node && nodeData.primitiveKey === "$output" && nodeData.primitiveValue.substr(1, nodeData.primitiveValue.length-2).trim() === "this") {
        __perchanceError("The module called <code><a href='/"+moduleName+"#edit'>"+moduleName+"</a></code> has <code>$output</code> set to <code>[this]</code>. Perchance does this by default, so this line should be removed. That is, if you don't specify a top-level <code>$output</code> (the list you want to export) for your generator, then Perchance will export your <i>whole hierarchy</i>.", nodeData.declarationLineNumber);
        return;
      }

      Object.defineProperty(nodeData.parentNode, lines[i].primitiveKey, {
        get:function() {
          // MARKER:odj29hfi3j0d2kj0hx24f
          if(node.$isPlainPrimitive) {
            // When a user writes `thing.prop` we want them to be able to access the proper string (with escape chars removed), but the problem
            // is that we use this same getter in the evaluateText process, and we definitely don't want to remove escapes during that process
            // because it gets recursively evaluated so we'd be removing backslashes and evaluating blocks that should be evaluated. The toString
            // method also had this problem, but I solved it by passing in a {keepEscapes:true} object when it is used in the evaluateText process,
            // but since this is a getter, we can't pass in arguments, so I've used mega hax to do it (use global var). See the evaluateText function
            // file for the actual location where this var is altered. It should always be false except for when it is used during the evaluateText process.
            if(typeof node.$value === "string" && !window.__primitiveValueGetterKeepEscapesYolo) return __processEscapedCharacters(node.$value);
            else return node.$value;
          }
          if(typeof node.$value === 'number') {
            return node.$value;
          } else if(typeof node.$value === 'string') {

            // EDIT: (7th Aug 2019), realised due to [this post](https://www.reddit.com/r/perchance/comments/cmlfqh/imported_expression_returns_undefined/)
            // that they can have something like:
            //   name = BATMAN
            //   $output
            //     n = ["[name]"]
            // and the IMPORTING generator's `name` variable will be used instead, since we're only resolving the first "layer" of square brackets. If the
            // getter returns a string, I'm pretty sure it should be a FULLY RESOLVED string (otherwise why resolve the first layer at all?). If you really do
            // want to pass around unresolved strings, then you're probably a pro and you know how to use functions and stuff.
            // example:
            //  imported: https://perchance.org/imported-2324234#edit
            //  importer: https://perchance.org/importing-93845793#edit
            let splitted = __splitTextAtAllBlocks(node.$value, {declarationLineNumber:node.$declarationLineNumber});
            if(splitted.length === 1) {
              if(splitted[0][0] === "[" /*&& splitted[0][splitted[0].length-1] === "]"*/) {
                // we don't want to evaluateText on this because it'll be coerced into a string (we want to preserve "direct" references)
                let expression = node.$value.substr(1,node.$value.length-2);
                let result = __evaluateSquareBlock(node.$root, node.$parent, expression, {declarationLineNumber:node.$declarationLineNumber});
                while(1) {
                  if(typeof result === "string") {
                    // if it is a single square block, we need to preserve direct references to other nodes - if not we can just evaluateText
                    let newSplitted = __splitTextAtAllBlocks(result, {declarationLineNumber:node.$declarationLineNumber});
                    if(newSplitted.length === 1 && newSplitted[0][0] === "[") {
                      let expression = result.substr(1,result.length-2);
                      result = __evaluateSquareBlock(node.$root, node.$parent, expression, {declarationLineNumber:node.$declarationLineNumber});
                    } else {
                      // it's definitely not one lone square block, so it's definitely not a direct reference and thus we can just resolve it to plain text:
                      result = __evaluateText(node.$root, node.$parent, result, {declarationLineNumber:node.$declarationLineNumber});
                      break;
                    }
                  } else {
                    break;
                  }
                }
                return result;
              } else if(splitted[0][0] === "{" /*&& splitted[0][splitted[0].length-1] === "}"*/) {
                //let expression = node.$value.substr(1,node.$value.length-2);
                //return __evaluateCurlyBlock(node.$root, node.$parent, expression, {declarationLineNumber:node.$declarationLineNumber});
                //return "{"+expression+"}";
                // ---
                // return node; // for square blocks we evaluate it to get a direct reference, but there's no need for this with curly blocks (we let toString do the evalation)
                // EDIT: (read above 7th Aug 2019 realisation - we need to do the evaluation ourselves so that it's evaluated within THIS generator's scope (in terms of `this` and global variables)):
                // return evaluateText(node.$root, node.$parent, node.$value, {declarationLineNumber:node.$declarationLineNumber});
                // EDIT AGAIN: NOPE! Luckily, this is a *node*, not a string, so the future toString will keep the correct context. If we evaluateText here, then you end up not being able to make
                //             a consumableList from an "inline" list like `icecreamflavor = {chocolate|vanilla|pistachio}` because `icecreamflavor` immediately resolves to one of the flavours as reported here: https://www.reddit.com/r/perchance/comments/co6msx/bug_list_name_being_included_in_output_of_list/ewgjzmm/
                return node;
              } else {
                // // plain text (no curly or square blocks) - LATER: why do we need to evaluate it then? not necessary?
                //return evaluateText(node.$root, node.$parent, node.$value, {declarationLineNumber:node.$declarationLineNumber});
                return __processEscapedCharacters(node.$value); // <-- WAIT - this will never occur?? The if(node.$isPlainPrimitive) above will catch all plain text nodes.
              }
            } else {
              // we've found a non-direct reference that's not plain text.
              // we need to return the *actual node* because otherwise if we have `output = [prefix]-blah` (for example)
              // then we couldn't call `output.selectMany(3)` on it because `output` would be a plain string (like "pseudo-blah", for example).
              // note that when used on $value nodes, selectOne will just return the node itself
              return node;
              // var n = node.createClone;
              // n.$nodeType = "text";
              // Object.defineProperty(lines[i].node, "$text", {value:n.$value, writable:true, configurable:true});
              // Object.defineProperty(lines[i].node, "$oddsText", {value:"1", writable:true, configurable:true});
              // delete n.$key;
              // delete n.$value;
              // return n;
            }

          } else if(typeof node.$value === 'boolean') {
            return node.$value;
          } else {
            //console.error("Something went wrong? $value should be either a number, string, or boolean, right?");
            return node.$value; // June 11th 2019: It's a direct reference to another node, or a reference to an objext or something. (I thought I was tyding direct references up somewhere else, but that wouldn't cut it anyway because they can change the value now that there's a setter (e.g. to a POJO or whatever))
          }
        },
        set:function(v) { // June 11th 2019: Added this setter - why wasn't it set already? If it's not set then we can't change it and we get problems like this: https://www.reddit.com/r/perchance/comments/bz2smn/one_of_the_example_generator_is_broken_i_think_i/
          node.$value = v;
          return v;
        },
        configurable:true,
      });

      Object.defineProperty(lines[i].node, "$nodeType", {value:"value", writable:true, configurable:true});
      Object.defineProperty(lines[i].node, "$text", {value:lines[i].primitiveKey, writable:true, configurable:true});

      nodeData.parentNode.$valueChildren.push(lines[i].primitiveKey);
    }

  }

  // add $children property to each node (an array of all of the keys of the node's non-primitive, non-function children that are leaf nodes (i.e. that are themselves childless))
  // TODO: final confirmation: this should be just the keys, right? or would it be more useful to people as nodes? what are use cases of this property? [animal.$children] - actually yeah, it makes sense that it returns a key - if it returned an object then a random child of THAT object would be chosen!
  for(let node of allNodes) {
    let keys = Object.keys(node).filter(k => node[k].$nodeType === 'normal').sort((k1,k2) => node[k1].$declarationLineNumber-node[k2].$declarationLineNumber); // filter out primitives and sort by the actual order of the list
    Object.defineProperty(node, "$children", {value:keys, writable:true, configurable:true});
  }

  // // error if any of the **direct children of root** aren't valid javascript identifiers.
  // // this is necessary for two reasons:
  // // 1. calling [else] will throw an error - but [thing.else] will not
  // // 2. calling [my list] will throw an error - but [thing["my list"]] will not
  // let warnLineNumbers = [];
  // for(let key of root.node.$children) {
  //   if(!isValidJavaScriptIdentifier(key)) {
  //     warnLineNumbers.push( root.node[key].$declarationLineNumber );
  //   }
  // }
  // if(warnLineNumbers.length > 0) {
  //   if(warnLineNumbers.length > 10) {
  //     warnLineNumbers = warnLineNumbers.slice(1,9);
  //     warnLineNumbers.push("...");
  //   }
  //   console.warn(`Warning at line number${(warnLineNumbers.length > 1 ? "s" : "")+" "+warnLineNumbers.join(", ")}. All *top-level* items must only include letters, numbers and underscore characters (no spaces or special characters). They also must not start with a number. They also must not be any of these "reserved" names: break, do, instanceof, typeof, case, else, new, var, catch, finally, return, void, continue, for, switch, while, debugger, function, this, with, default, if, throw, delete, in, try class, enum, extends, super, const, export, import, implements, interface, let, package, private, protected, public, static, yield`);
  // }

  // TODO: add module name to all errors, or print module name when you catch errors
  // TODO: add "need help?" link to all errors that links to community (reddit, probably)

  // extract import statements:
  let importedModuleNamesArray = [];
  __ignorePerchanceErrors = true;
  for(let line of lines) {
    if(line.nodeType === 'function' || line.node.$isPlainPrimitive) continue;
    let names = __collectImportedModuleNamesFromText(line.text);
    importedModuleNamesArray.push(...names);
  }
  __ignorePerchanceErrors = false;
  Object.defineProperty(root.node, "$imports", {value:[...new Set(importedModuleNamesArray)], writable:true, configurable:true});


  Object.defineProperty(root.node, "$allNodes", {value:allNodes, writable:true, configurable:true});



  // for(let node of allNodes) {
  //   if(node.$constructorFunction.prototype !== undefined) {debugger;}
  //   Object.defineProperties(node.$constructorFunction.prototype, Object.getOwnPropertyDescriptors(node));
  // }

  const allowedDollarVariables = ["$output", "$preprocess"];
  for(let node of root.node.$allNodes) {
    if(node.$nodeType === "value" && node.$text[0] === "$" && !allowedDollarVariables.includes(node.$text)) {
      __perchanceError(`There's a problem with the '${moduleName}' generator. You've created a property with a name that starts with "$". This is highly discouraged because dollar-sign variables are reserved for special features such as $output and $preprocess. New features that are added to Perchance in the future may use other dollar-sign variable names and these may conflict with your variable-name choice and thus cause errors.`, node.$declarationLineNumber);
      continue;
    }
    // I use `moduleName !== null` here to hackily exclude the name check if this run of createPerchanceTree is due to a call of the createClone function (the only case where no module name is allowed). In this case it's fine for top-level nodes to have names to be invalid JS identifiers, because they aren't referencable as if they were global variables.
    // Note that if this is a call to createClone, then `root` isn't the "real" root and is discarded once we've created the clone.
    if(moduleName !== null && node.$parent === root.node && (!__isValidJavaScriptIdentifier(node.$text) || node.$text === "update")) {
      __perchanceError(`There's a problem with the '${moduleName}' generator. You've created a top-level list called "<b>${__escapeHTMLSpecialChars(node.$text)}</b>", which is not allowed. Unfortunately top-level list names are subject to some strict rules:<ul><li>They must not contain any spaces</li><li>They must only contain letters (lower or upper case), numbers and underscores ("_")</li><li>They must not begin with a number</li><li>They must not be any of the following special "reserved" names: update, do, if, in, for, let, new, try, var, case, else, enum, eval, null, this, true, void, with, await, break, catch, class, const, false, super, throw, while, yield, delete, export, import, public, return, static, switch, typeof, default, extends, finally, package, private, continue, debugger, function, arguments, interface, protected, implements, instanceof</li></ul> Sorry for the inconvenience! These rules may seem strange, but they're needed to make the more advanced features of the perchance engine work.`, node.$declarationLineNumber);
    }
  }



  let fn = function(){};
  fn.obj = root.node;
  let rootProxy = new Proxy(fn, {
      capturedCalls: [],
      executionProperties: [
        "toString",
        "valueOf",
        Symbol.hasInstance,
        Symbol.isConcatSpreadable,
        Symbol.iterator,
        Symbol.match,
        Symbol.prototype,
        Symbol.replace,
        Symbol.search,
        Symbol.species,
        Symbol.split,
        Symbol.toPrimitive,
        Symbol.toStringTag,
        Symbol.unscopables,
        Symbol.for,
        Symbol.keyFor,
        "selectMany",
        "selectOne",
        "selectAll",
        "getSelf",
        "getName",
        "$imports",
        "$allNodes",
        "$odds",
        "$text",
        "$value",
        "$key",
        "$nodeType",
        "$oddsText",
        "$declarationLineNumber",
        "$moduleName",
        "$root",
        "$parent",
        "$children",
        "isConsumable",
        "consumableList",
        "createClone",
        "evaluateItem",
        "joinItems",
        //"listName",
        // TODO: add new items here whenever you add any new special properties
      ],
      organiseCalls: function(capturedCalls) {
        // CAREFUL: do not move `apply`s away from their correct `get`
        let textTransforms = [];
        let nonTextTransforms = [];
        let inApplyChain = false;
        for(let i = 0; i < capturedCalls.length; i++) {
          let call = capturedCalls[i];
          if(call.type === "get" && textTransformNames.includes(call.name)) {
            // if(i+1 < capturedCalls.length && capturedCalls[i+1].type === "apply") {
            //   perchanceError(`Tried to call a text transform '${call.name}' as a function/method. Text transforms like ${call.name}, pluralForm and titleCase are not functions. They shouldn't be followed by a pair brackets.`);
            // }
            textTransforms.push(call);
            inApplyChain = true; // any `apply`s after this text transform must be moved with it

          } else if(call.type === "apply" && inApplyChain) {
            textTransforms.push(call);
          } else {
            nonTextTransforms.push(call);
            inApplyChain = false;
          }
        }
        let organisedCalls = [];
        organisedCalls.push(...nonTextTransforms);
        organisedCalls.push(...textTransforms);
        // TODO***: should text transforms be applied before joinItems?
        return organisedCalls;
      },
      executeChain: function(target, calls) {
        let result = target.obj;

        // let disable$output = false;
        // if(calls.map(c=>c.name).includes("disable$output")) {
        //   debugger;
        //   disable$output = true;
        // }

        if(calls.length === 0) {
          return target.obj;
        }

        // move text transforms to end (importantly, this method doesn't change the this.capturedCalls array - it returns a new one)
        let capturedCalls = this.organiseCalls(calls);

        let lastResult, secondLastResult;
        for(let i = 0; i < capturedCalls.length; i++) {
          let call = capturedCalls[i];

          secondLastResult = lastResult; // needed for `apply` (since LAST result is the actual function, and not the object/thing that it's being being called from)
          lastResult = result;

          if(call.type === "get") {
            result = result[call.name];
            if(result === undefined && i === 0) {
              result = window[call.name]; // try to fallback to global `window` if there's no list/function/property found - e.g. if they did [Math.min(hp, 100)] - "Math" is not a list
            }
          } else if(call.type === "apply") {
            // in my case the `this` variable should be the thing that the method is being called from
            // (this is done by default with getters)
            result = result.apply(secondLastResult, call.args);
          } else {
            console.error("How could this be?");
          }

          if(result === undefined) {
            // we DON'T return an error message because they may just want to check if the property exists.
            return undefined;
          }

          // Remember that `result` could be a Proxy (imagine `$output = [noun.pluralForm]` - root.$output is a proxy with `noun` and `pluralForm` in the capturedCalls array (because $value nodes are evaluated when called (using a `get` handler))).
          // If it IS a proxy, we want to append this proxy's capturedCalls array to the new one and execute it:
          if(result.___isProxy) {
            let leftOverCalls = capturedCalls.slice(i+1);
            let allCalls = [...result.___proxyHandler.capturedCalls, ...leftOverCalls];
            // TODO: just to confirm, we don't need to pass along secondLastResult do we? What if they called `apply` twice in a row? It's an edge case that might be annoying to debug later on
            return this.executeChain(result.___proxyTarget, allCalls);
          }

        }
        return result;
      },
      userDefinedNonNodePropertyIds: {},
      getUserDefinedNonNodePropertyId: function(property, calls) {

        // In case you're wondering what on earth is going on here:
        // We need to get the proxy to return properies that the USER has set with scripts (in square blocks, functions, etc.).
        // So we need to keep track of when they add their own properties to `root`.
        // That way, when the proxy gets a `get` request for one of these "non-node" properties, it can return it straight up.
        // Basically, any properties added to root AFTER compilation will always be returned in get requests (rather than returning a proxy).

        // This will probably cause memory leaks if they're setting properties on root with dynamically generated names?

        let seperator = "_{9287234632<<prop-id-call-seperator>>4632877592}_";
        let id = "root";
        for(let call of calls) {
          if(call.type === "apply") {
            return false;
          }
          id += seperator + call.name;
        }
        id += seperator + property;
        return id;
      },
      isUserDefinedNonNodeProperty: function(property, calls) {
        return this.userDefinedNonNodePropertyIds[ this.getUserDefinedNonNodePropertyId(property, calls) ] === true;
      },
      isFunctionNode: function(target, capturedCalls, property) {

        // If `property` is referencing a function node of target.obj, then we want to
        // return that function (not a proxy). That's why we need this function (we use it in the `get` handler)

        // if there are `apply`s in the capturedCalls, return false, since a function node can only be a
        // direct `get` chain from the root node (this is just an optimisation)
        for(let c of capturedCalls) {
          if(c.type === 'apply') return false;
        }

        let root = target.obj;

        // NOTE: we don't need to worry about user-defined non-node properties, because we detect them in the `get` trap
        // NOTE: remember, all nodes are functions, so be careful with your typeof logic (not used here anyway)
        let ref = root;
        for(let c of capturedCalls) {
          if(ref.$children.includes(c.name)) ref = ref[c.name];
          else return false;
        }
        if(ref.$functionChildren.includes(property)) return true; // the call path DOES reference a function node
        else return false;

        // OLD APPROACH: I have no idea why I was doing the reverse-lookup thing in this old approach. To get around proxy "looping" stuff???
        // // Here's what we do:
        // // 1. if there are `apply`s in the capturedCalls, return false, since a function node can only be a
        // //    direct `get` chain from the root node (this is just an optimisation)
        // // 2. For each occurrance of `property` in root.$allNodes that is a `value` or `function` node, trace
        // //    back up the $parent chain, checking at each stage that it matches the capturedCalls `get` names
        // //    in reverse order. If you get back to root, run the capturedCalls on root and see if it's a function.
        // //    If it is, return true. Otherwise continue.
        // // 3. If no matches, return false.
        //
        //
        // for(let c of capturedCalls) {
        //   if(c.type === 'apply') return false;
        // }
        //
        // let root = target.obj;
        //
        // for(let node of root.$allNodes) {
        //   if(node.$text !== property) continue;
        //   if(node.$nodeType !== 'value' && node.$nodeType !== 'function') continue;
        //
        //   // so we know it's a value or function node, and we know the `property` matches its name.
        //   // now we need to check if the node's ancestry chain back to root matches the capturedCalls array
        //
        //   let traceNode = node.$parent;
        //   for(let i = capturedCalls.length-1; i >= 0; i--) {
        //     if(capturedCalls[i].name !== traceNode.$text) break;
        //     traceNode = traceNode.$parent;
        //   }
        //
        //   if(traceNode === root) { // found a full path/ancestry match
        //     // now we just need to check if it's a function:
        //     let ref = root;
        //     for(let c of capturedCalls) { ref = ref[c.name]; }
        //     // i replaced the below two commented out lines with the third to help solve some `get` loops happening in the proxy with this.isFunctionNode
        //       // ref = ref[property]; // the final `get`
        //       // if(typeof ref === 'function') return true; // found a function node!!!
        //     if(ref.$functionChildren.includes(property)) return true; // found a function node!!!
        //   }
        //
        // }
        //
        // return false;

      },
      isGetterProperty: function(target, property) {
        let desc = Object.getOwnPropertyDescriptor(target.obj, property);
        return desc && desc.get;
      },
      get: function(target, property, receiver) {

        // commenting this out for now in favor of the perchance.org/my-generator#debugFreeze approach
        // if(window.globalProxyLoopCount > 10000000) {
        //   throw new Error("It seems like you've got an infinite loop somewhere in your code. Are you referencing a list name within a child of that list, such that it creates an infinite loop?");
        // }
        // window.globalProxyLoopCount++;


        if(property === "___isProxy") { return true; }
        if(property === "___proxyTarget") { return target; }
        if(property === "___proxyHandler") { return this; }
        // if(property === "___addExecutionPath") {
        //   let last = this.capturedCalls[this.capturedCalls.length-1];
        //   this.capturedCalls.pop();
        //   this.userDefinedNonNodePropertyIds[ this.getUserDefinedNonNodePropertyId(last, this.capturedCalls) ] = true;
        // }

        //if(this.isGetterProperty(target, property) || this.executionProperties.includes(property) || this.isUserDefinedNonNodeProperty(property, this.capturedCalls) || this.isFunctionNode(target, this.capturedCalls, property)) {
        if(true) { // testing out resolving all `get`s (QUESTION: was the only reason why we needed proxies for stuff like `pluralAnimalList = [animal.pluralForm]`? because that's really not needed anyway, and I don't think it's even possible in perchance's current state)

          let result = this.executeChain(target, this.capturedCalls);

          // if(typeof result === 'string' || typeof result === 'number')
          //   return result;

          if(result === undefined) {
            if(property === Symbol.toPrimitive) {
              return function() { return undefined; }
            } else {
              __perchanceError(`the list/variable <code>${this.capturedCalls.map(c=>c.name).join("→")}</code> doesn't seem to exist in the <code>${target.obj.$moduleName}</code> generator.`);
              // if(property === Symbol.toPrimitive) return function() { return "(error)"; }
              return "(error)";
            }
          }

          let finalResult = result[property];
          if(typeof finalResult === 'function' && !finalResult.___isProxy) {
  			    finalResult = finalResult.bind(result);
          }
          return finalResult;

        } else {
            // need to return new proxy
            let newHandler = {};
            Object.assign(newHandler, this);
            newHandler.capturedCalls = this.capturedCalls.slice(0);

            newHandler.capturedCalls.push({type:"get", name:property});
            let np = new Proxy(target, newHandler)
            return np;
        }
      },
      apply: function(target, thisArg, args) {
          // // return a new proxy:
          // let newHandler = {};
          // Object.assign(newHandler, this);
          // newHandler.capturedCalls = this.capturedCalls.slice(0);
          // // add arguments to last call that was captured
          // newHandler.capturedCalls.push({type:"apply", args});
          // let np = new Proxy(target, newHandler);
          // return np;

          // i commented out the above code and added this because we always want functions to resolve immediately. otherwise we get this problem (see comment in bottom left): https://i.imgur.com/SY9MOt8.png -- as another example, people needed to write [a = dice("1d6").selectOne] instead of just [a = dice("1d6")]
          // maybe I should make exceptions for joinItems and those other inbuilt functions?
          this.capturedCalls.push({type:"apply", args});
          return this.executeChain(target, this.capturedCalls);
      },
      set: function(target, property, value, receiver) {
        // resolve it if it's a proxy (to prevent infinite loops when you do something like [abc=abc] (where abc is an already-defined top-level node), since that would set abc to its own proxy, so when you resolve it, it would resolve to the proxy, and the loop continues)
        if(value && value.___isProxy) {
          value = value.___proxyHandler.executeChain(value.___proxyTarget, value.___proxyHandler.capturedCalls);
        }

        let obj = this.executeChain(target, this.capturedCalls);
        if(typeof obj !== 'object') {
          __perchanceError(`You tried to set <code>${__escapeHTMLSpecialChars(this.capturedCalls.map(c=>c.name).join("."))}</code> to <code>${__escapeHTMLSpecialChars(value)}</code>, but it appears that <code>${__escapeHTMLSpecialChars(this.capturedCalls.map(c=>c.name).join("."))}</code> does not exist, or some other strange error has occurred.`);
          return;
        }
        Object.defineProperty(obj, property, {value, writable:true, configurable:true}); // importantly we're executing defineProperty on an actual object, NOT a proxy
        this.userDefinedNonNodePropertyIds[ this.getUserDefinedNonNodePropertyId(property, this.capturedCalls) ] = true;
        return value;
      },
      isExtensible: function(target) { return Object.isExtensible(this.executeChain(target, this.capturedCalls)); },
      preventExtensions: function(target) { return Object.preventExtensions(this.executeChain(target, this.capturedCalls)); },
      getOwnPropertyDescriptor: function(target, prop) { return Object.getOwnPropertyDescriptor(this.executeChain(target, this.capturedCalls), prop); },
      defineProperty: function(target, property, descriptor) { return Object.defineProperty(this.executeChain(target, this.capturedCalls), property, descriptor); },
      has: function(target, prop) { return (prop in this.executeChain(target, this.capturedCalls)); },
      deleteProperty: function(target, property) { return delete this.executeChain(target, this.capturedCalls)[property]; },
      ownKeys: function(target) { return Reflect.ownKeys(this.executeChain(target, this.capturedCalls)); }
  });
  window.__rootProxyHasHandler = rootProxy.___proxyHandler.has;

  // add this module to modulespace now otherwise our functions won't work for the direct-reference checks
  // yolo
  window.moduleSpace[moduleName] = rootProxy;

  // EDIT: don't need this any more now that we've got isFunctionNode?
  // make user-defined functions execute immediately upon being called (i.e. don't return a proxy)
  // for(let i = 0; i < allNodes.length; i++) {
  //   if(allNodes[i].$nodeType === "function") {
  //     let node = allNodes[i];
  //     // we found a function, now lets build a call chain to it
  //     let calls = [];
  //     while(node.$parent) {
  //       calls.unshift(node.$parent.$text);
  //       node = node.$parent;
  //     }
  //     calls.shift(); // remove "<root>"
  //     let chain = [rootProxy];
  //     for(let c of calls) {
  //       chain.push(chain[chain.length-1][c]); // did it weirdly like this to prevent proxy setter being called
  //     }
  //     chain = chain[chain.length-1]; // the last element is the completed chain
  //     chain[allNodes[i].$text] = allNodes[i].$function; // EDIT: this calls the proxy setter and adds a "userDefinedNonNodeProperty" - was that the prupose?
  //   }
  // }


  // tie direct references to the actual nodes. e.g.:
  // animal = [african_animal]
  // $output = [person]
  // so rather than [animal] and [$output] being $value nodes, they'll directly reference [aftican_animal] and [person].
  // this is mainly needed to make $output behaviour sane.
  for(let node of allNodes) {
    if(node.$nodeType === "value" && !node.$isPlainPrimitive) {
      let blocks = __splitTextAtAllBlocks(node.$value, {declarationLineNumber:node.$declarationLineNumber});
      if(blocks.length === 1 && blocks[0][0] === "[" && blocks[0][blocks[0].length-1] === "]") {
        let expression = node.$value.substr(1,node.$value.length-2);

        // only create link if they're DIRECTLY referencing another list:
        if(__isValidJavaScriptIdentifier(expression)) {

          __ignorePerchanceErrors = true; // it may fail because it could reference a function that hasn't been linked yet (i have no idea what's going on)
          let refNode = __evaluateSquareBlock(root.node, node.$parent, expression, {declarationLineNumber:node.$declarationLineNumber});
          __ignorePerchanceErrors = false;

          if(refNode && refNode.$nodeType /*|| Array.isArray(refNode)*/) { // did it resolve to a node?
            node.$parent[node.$text] = refNode;
          }
        }

        // NOTE: curly IMPORT blocks get tied to their actual module after all imports are compiled (in iframe html)

        // TODO**: does all this work by default now because of the new proxy approach? can I remove this part all together?

        // TODO***: we need to pre-evaluate $output so it's a *direct* reference to the thing it references,
        //          but if we do that with other $value nodes, things can get messy:
        //
        // person
        //   name = [name.selectOne]
        //
        // `person.name` will always be same node!!
        // if we call update it stays the same
        // if we do [a = new person], the selection remains the same
        // etc. - tonnes of problems
        // here's why we WANT to be able to do this in the first place:
        // person
        // 	 name = [name.selectOne]
        // 	 gender = [this.name.gender]
        //
        // note that we can already do this sort of thing:
        //
        // person
        // 	 age = {1-100}
        // 	 isAdult = [this.age > 18]
        //
        // potential solution: only pre-evaluate it if it's a direct reference to another node
        // (just like $output always is).

      }
    }
  }

  // give each node an id:
  for(let i = 0; i < allNodes.length; i++) {
    Object.defineProperty(allNodes[i], "$id", {value:i, writable:true, configurable:true});
  }



  // fix up $root references so they point to proxy instead of actual node
  // also remove node data symbol stuff
  // TODO***: what about $parent references - should they be proxied too?
  for(let i = 0; i < allNodes.length; i++) {
    Object.defineProperty(allNodes[i], "$root", {value:rootProxy, writable:true, configurable:true});
    delete allNodes[i][Symbol.for("node data")];
  }

  // at the moment, this is mainly so that other users don't get confused about strange syntax - they can easily see there's a preprocessor,
  // but in the future I may speed up preprocessing by just grabbing the function from the top, compiling that, and then running the code through it.
  // (instead of compiling the whole thing just to get the $preprocess function, as is happening now.) EDIT: oh, don't forget they can *import* preprocessor too!
  if(root.node.$preprocess && root.node.$allNodes[1].$text !== "$preprocess") {
    __perchanceError(`There's a problem with the '${moduleName}' generator. The special <code>$preprocess</code> function must be placed above all your other lists - at the very top of the Perchance code editor.`);
    return;
  }

  if(root.node.$preprocess && !doNotPreprocess) {
    let preprocess;
    if(typeof root.node.$preprocess.nodeType === 'function') {
      preprocess = root.node.$preprocess;
    } else {
      if(!root.node.$preprocess.$value.startsWith("{import:")) return __perchanceError(`There's a problem with the '${moduleName}' generator. The special <code>$preprocess</code> property must be defined as a function, or an imported function.`);
      let preprocessorName = root.node.$preprocess.$value.slice(8, -1);
      let module = window.moduleSpace[preprocessorName];
      if(!module) return __perchanceError(`There's a problem with the '${moduleName}' generator. The preprocessor '${preprocessorName}' could not be found?`);
      if(!module.$output || !module.$output.$nodeType === "function") return __perchanceError(`There's a problem with the '${moduleName}' generator. The '${preprocessorName}' was imported into '${moduleName}' as a preprocessor function, but the <code>$output</code> of '${preprocessorName}' doesn't exist or is not a function?`);
      preprocess = module.$output;
    }
    let newInputText = preprocess(root.perchanceCode);
    return __createPerchanceTree(newInputText, moduleName, backupModuleName, true);
  }

  console.log(`${moduleName} init: ${Date.now()-functionStartTime}ms`);

  return rootProxy;
  //return root.node;


  // notes:
  // TODO: remove todos that are already done...
  // TODO: primitive declarations using "=" and update toString so it ignores primitive-valued properties
  // TODO: in toString: add {a|b|c} notation handling (recusive)
  // TODO: add array handling: we just treat ["a", "b^2", "c"] like {a|b^2|c} when Array.toString() is called (use the same back-end function)

  // TODO: if we across duplicate sibling nodes, what do we do? just make the latter overwrite the prior? add the odds together?

}


// this is very hacky...
function __duplicatePerchanceNode(originalNode) {
  originalNode = originalNode.getSelf;

  // NOTE: node will be unreferencable from parent (since the node to be duplicated already holds that key).
  //       I think this is fine? They can always add it to the parent if some weird situation required that.

  let root = __createPerchanceTree(originalNode.$perchanceCode, null, originalNode.$moduleName);
  root = root.getSelf; // get target object, not proxy

  for(let node of root.$allNodes) {
    if(node === root) continue;
    node.$id = originalNode.$root.getSelf.$allNodes.length;
    originalNode.$root.getSelf.$allNodes.push(node);

    node.$root = originalNode.$root.getSelf;
    node.$moduleName = originalNode.$moduleName;
    // I think this is causing some problems when it tries to get a node of a "directly linked" property:
    //node.$declarationLineNumber = getCorrespondingOriginalNode(node).$declarationLineNumber;
  }

  // function getCorrespondingOriginalNode(clonedNode) {
  //   let propertyChain = [];
  //   let n = clonedNode;
  //   while(n.$parent) { // get chain up to cloned root
  //     propertyChain.unshift(n.$text);
  //     n = n.$parent;
  //   }
  //   n = originalNode.$parent.getSelf
  //   while(propertyChain.length) { // evaluate chain from original node's parent
  //     n = n[propertyChain[0]];
  //     propertyChain.shift();
  //   }
  //   return n;
  // }

  let node = root[originalNode.$text];
  node.$parent = originalNode.$parent.getSelf;

  return node;

}


function __escapeHTMLSpecialChars(unsafe) {
    return unsafe.toString()
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
 }

function __collectImportedModuleNamesFromText(text) {
  let blocks = __splitTextAtAllBlocks(text);
  let moduleNames = [];
  for(let b of blocks) {
    if(b[0] === "{") {
      let match = /^\{import:([a-z0-9\-]+)\}$/.exec(b);
      if(match && match.length > 1) {
        moduleNames.push( /^\{import:([a-z0-9\-]+)\}$/.exec(b)[1] );
      } else {
        moduleNames.push( ...__collectImportedModuleNamesFromText( b.substr(1, b.length-2) ) );
      }
    }
  }
  return [...new Set(moduleNames)];
}

// function evaluateTextAsNumber(rootNode, thisRef, text, ctxInfo) {
//   // NOTE: This function is NOT for evaluating odds expressions!
//   // NOTE: this only returns the number if it can be "exactly" converted
//   // into a number - it doesn't evaluate the string's mathematical operators
//   // or anything like that. It only returns if text === String(Number(text))
//   // because that mean indicates that the deliberately typed a number, and even if
//   // they didn't, the toString conversion that occurs when this number is output
//   // will give **exacttly the same result anyway**.
//   let value = __evaluateText(rootNode, thisRef, text, ctxInfo);
//   if(value === String(Number(value))) {
//     return Number(value);
//   } else {
//     return false;
//   }
// }

function __evaluateText(rootNode, thisRef, text, ctxInfo, previousEvaluationText) {

  // IMPORTANT: Some curly functions may "return themselves" i.e. {a} may return "{a}" rather than "a" or "an" - this
  //            behaviour is allowable because evaluateText is called recursively until no unescaped curly/square blocks
  //            exist. The reason curly functions may do this is because parts of their arguments (the two strings either side of
  //            "{a}" in the case of the "{a}" function) may not have been evaluated yet, and it may rely on those parts having
  //            been evaluated. e.g. in the text "{a} [animal] is over there", {a} must wait until [animal] has been evaluated.
  // ALSO NOTE: previousEvaluationText is needed because (for example) if we evaluate "created {a}", there's nothing after {a} for
  //            us to detemrine whether we should use "a" or "an". But "created {a}" is still valid because they could be using it
  //            as part of a larger sentence. If `text` evaluates to `previousEvaluationText`, then we just return it rather than
  //            recuring infinitely.
  // ALSO NOTE: I had to change this so that instead of [passing through once and then checking if there are any unevaluated blocks that would
  //            require another pass-over], it does the recursion *within* the loop - otherwise things get executed out of order (e.g. assignment of
  //            variables and stuff). The user expects their variable assignments to happen in the order that the final output text is printed in.
  //            Edit: Oh, but I still need to recurse at the end, because some curly blocks like {a} may only be executable once all the blocks are
  //            joined together into one string.
  // ALSO NOTE: This function DOESN'T call processEscapedCharacters on the output. That must be called on the result.

  var bracketRegex = /[\[\]{}]/; // note: this is used further down too

  if(!bracketRegex.test(text)) return text; // if it has no brackets, nothing needs evaluating

  var blocks = __splitTextAtAllBlocks(text, ctxInfo);
  // iterate through and evaluate each block
  var evaluatedBlocks = [];
  var block, leftBlocks, rightBlocks;
  for(let i = 0; i < blocks.length; i++) {
    block = blocks[i];
    leftBlocks = blocks.slice(0,i);
    rightBlocks = blocks.slice(i+1);

    if(block[0] === "{") {

      let input = block.substr(1,block.length-2);
      let result = __evaluateCurlyBlock(rootNode, thisRef, input, leftBlocks, rightBlocks, ctxInfo);

      if(result && (typeof result === "object" || typeof result === "function") && result.$nodeType) {
        // This could be a Perchance node due to import blocks. See note below the `__evaluateSquareBlock` call below for explanation.
        result = result.toString({keepEscapes:true});
      } else {
        result = result + "";
      }

      // the first few conditions here are just performance optimisations:
      if(result !== block && bracketRegex.test(result) && (result[0] === "[" || result[0] === "{" || __splitTextAtAllBlocks(result).length > 1)) {
        result = __evaluateText(rootNode, thisRef, result, ctxInfo, result);
      }
      evaluatedBlocks.push(result);

    } else if(block[0] === "[") {

      let input = block.substr(1,block.length-2);
      window.__primitiveValueGetterKeepEscapesYolo = true; // see MARKER:odj29hfi3j0d2kj0hx24f for explanation
      let result = __evaluateSquareBlock(rootNode, thisRef, input, ctxInfo);
      window.__primitiveValueGetterKeepEscapesYolo = false;

      if(result && (typeof result === "object" || typeof result === "function") && result.$nodeType) {
        // If it's a Perchance node, we keep the escape characters, since if we remove them here, then we would unescape square/curly character (for example) and
        // then they'd get executed (in the code that follows this block) even though that's obviously not what the user wants. See the comments at the top of the toString
        // function for more context.
        result = result.toString({keepEscapes:true});
      } else {
        result = result + "";
      }

      // the first few conditions here are just performance optimisations:
      if(result !== block && bracketRegex.test(result) && (result[0] === "[" || result[0] === "{" || __splitTextAtAllBlocks(result).length > 1)) {
        result = __evaluateText(rootNode, thisRef, result, ctxInfo, result);
      }
      evaluatedBlocks.push(result);

    } else {
      evaluatedBlocks.push(block);
    }
  }

  if(previousEvaluationText === evaluatedBlocks.join("")) return previousEvaluationText; // see note at top of this function for explanation

  // if there's anything but plain text (i.e. if there's any curly/square blocks), recurse
  var b, completelyEvaluated = true;
  for(let i = 0; i < evaluatedBlocks.length; i++) {
    b = evaluatedBlocks[i];
    if(!bracketRegex.test(b)) continue;
    //if(b === undefined) { b = evaluatedBlocks[i] = "(not found)"; }
    if(b[0] === "[" || b[0] === "{" || __splitTextAtAllBlocks(b).length > 1) {
      completelyEvaluated = false;
      break;
    }
  }

  if(!completelyEvaluated) {
    return __evaluateText(rootNode, thisRef, evaluatedBlocks.join(""), ctxInfo, evaluatedBlocks.join(""));
  } else {
      return evaluatedBlocks.join("");
  }

}

function __processEscapedCharacters(text) {

  //TODO***: when they have an item like `\ hello \` and they repeat it like [item][item][item]... you end up with `hello \ hello \ hello \ ...` because the two backslashes join up.
  //         I think this is pretty easy: if there's an unescaped backslash on the end, remove it when you create the node.
  //         If there's one at the start and it's just escaping a space, then remove that backslash too.

  // TODO***: allow them to escape forward slashes?
  // TODO***: empty character "\e"?

  // look for input characters that follow an unescaped backslash
  // and replace them with the output character and remove the backslash

  let escapableCharacters = [
    {input:"=", output:"="},
    {input:"{", output:"{"},
    {input:"}", output:"}"},
    {input:"[", output:"["},
    {input:"]", output:"]"},
    {input:"^", output:"^"},
    {input:"|", output:"|"},
    {input:"n", output:"\n"},
    {input:"t", output:"\t"},
    {input:"s", output:" "},
  ];

  let escaped = false;
  for(let i = 0; i < text.length; i++) {
    if(i !== 0) {
      if(text[i-1] !== "\\") {
        escaped = false;
      }
    }

    if(text[i] === "\\") {
      if(escaped) { // handle the special case of the backslash character:
        escaped = false;
        text = text.substr(0, i-1) + "\\" + text.substr(i+1);
        i--;
      } else {

        if(i === text.length-1) {
          return text.substr(0, text.length-1); // if last character is an unescaped backslash, return text without it
        } else {
          escaped = true;
        }

      }
      continue;
    }

    if(escaped) {
      for(let e of escapableCharacters) {
        if(text[i] === e.input) {
          text = text.substr(0, i-1) + e.output + text.substr(i+1);
          i--;
          break;
        }
      }
    }

  }

  return text;

}

function __evaluateCurlyBlock(rootNode, thisRef, block, leftBlocks, rightBlocks, ctxInfo) {

  // `block` is a string of the *contents* of the curly block
  for(let fn of __curlyFunctions) {
    // note that recursion can occur here since some curly functions may neet to
    // resolve their arguments to plain text. So they'll call evaluatedText, which
    // will call this function (if curly brackets are found), and so the loop loops.
    let evaluatedBlock = fn(rootNode, thisRef, block, leftBlocks, rightBlocks, ctxInfo);
    if(evaluatedBlock !== false) {
      if(typeof evaluatedBlock === 'string' && String(Number(evaluatedBlock)) === evaluatedBlock) {
        return Number(evaluatedBlock);
      } else {
        return evaluatedBlock;
      }
    }
  }

  if(block === "s") {
    __perchanceError(`Your curly block "<code>{${__escapeHTMLSpecialChars(block)}}</code>" doesn't appear to have the correct syntax. It is meant to be used for something like <code>I have {1-3} [fruit]{s}</code>. Notice that there needs to be a number preceding the <code>[fruit]</code> block. If you just want the plural of <code>[fruit]</code> then you can use <code>[fruit.pluralForm]</code>.`, ctxInfo.declarationLineNumber);
  } else {
    __perchanceError(`Your curly block "<code>{${__escapeHTMLSpecialChars(block)}}</code>" doesn't appear to have the correct syntax. Curly brackets (these ones: {}) are special characters in Perchance. They're used to do all sorts of fancy stuff which you can learn about in the <a href="/tutorial">tutorial</a>. If you didn't intend to use a special function, and instead just wanted to actually use curly brackets as literal characters, then you can put a backslash character before them like so: \\{...\\}`, ctxInfo.declarationLineNumber);
  }
  return "(invalid curly block)";

}

// function evaluateCurlylessBlock(rootNode, text) {
//   // TODO: allow passing in the declarationLineNumber and other details to this function?
//   let arr = splitTextAtSquareBlocks(text);
//   let resultText = "";
//   for(let e of arr) {
//     if(e[0] === "[") {
//       let jsExpr = e.substr(1, e.length-2);
//       resultText += evaluateSquareBlock(rootNode, rootNode, jsExpr, {declarationLineNumber:null});
//     } else {
//       resultText += e;
//     }
//   }
//   return resultText;
// }

function __getTextOddsDetails(text) {
  // JUST returns text on either side of unescaped "^" that is in a TEXT block, with some minor validation (just to help users debug)

  let blocks = __splitTextAtAllBlocks(text);
  let blockI = 0;
  let charI = 0;
  let overallI = 0;
  let currentBlock = blocks[0];
  let inText = null;
  function inTextBlock(checkI) {
    // NOTE: we hold the state outside of the function so that we can start from where we left off
    if(overallI > checkI) {
      // start again if previous check state is past the current one
      blockI = 0;
      charI = 0;
      overallI = 0;
      currentBlock = blocks[0];
      inText = null;
    }

    while(true) {

      if(blockI > blocks.length-1) {
        console.error("The checkI value (index to be checked to see if it's within a TEXT block) seems to be greater than the length of the whole text.");
        return false;
      }

      // skip block if checkI doesn't occur within it
      if(charI === 0) {
        if(overallI + blocks[blockI].length-1 < checkI) {
          overallI += blocks[blockI].length; //don't subtract 1 because that would put overallI at last character of current block - we want it to be at the first character of nect block
          charI = 0; // not necessary since it already is zero, but just for expliciteness
          blockI++; // only increase block index after adding block size to overallI
          continue;
        }
      }

      if(charI === 0) {
        if(blocks[blockI][0] === "[" || blocks[blockI][0] === "{") {
          inText = false;
        } else {
          inText = true;
        }
      }

      if(overallI === checkI) {
        return inText;
      }

      if(charI === blocks[blockI].length-1) { // if we've reached the end of a block
        overallI++;
        blockI++;
        charI = 0;
      } else {
        charI++;
        overallI++;
      }

    }
  }

  //text = text.trim(); // <-- I commented this out because inline OR notation like { a ^1| b ^2} would return "a " or "b " instead or " a " or " b "
  let escaped = false;
  for(let i = 0; i < text.length; i++) {
    if(i !== 0) {
      if(text[i-1] !== "\\") { escaped = false; }
    }
    if(text[i] === "\\") { escaped = !escaped; }

    if(!escaped && inTextBlock(i) && text[i] === NODE_ODDS_INDICATOR_CHARACTER) {
      let odds = text.substr(i+1).trim();

      // tiny bit of validation, just to help out users, but definitely not an full validation (which would be basically impossible to do, since we'd need to simulate every possible combination of potentially huge programs)
      if(!/[!0-9\[\{]/.test(odds[0])) {
        __perchanceError(`There is a problem with this odds declaration: "<b>${__escapeHTMLSpecialChars(odds)}</b>" (the full text of the line with the error is "${__escapeHTMLSpecialChars(text)}"). The text after the "^" character defines the chance that that item will be selected (the higher the number the greater the chance). Odds declarations should only contain numbers, mathematical/logical operators, and are also allowed to have curly and square bracket blocks which will evaluate to number characters (these will be computed on-the-fly). If you'd like to use the "^" character literally (i.e. not to declare odds), you need to put a backslash character before it like so: "\\^"`);
        return false;
      }

      return {
        odds,
        textWithoutOdds: text.substr(0,i), // don't trim() - allow caller to decide, since different notations have difference whitespace preferences
      };
    }
  }

  return false;

}

function __oddsTextToNumber(rootNode, thisRef, text) {

  // optimisations:
  if(text === "1") { // default value:
    return 1;
  } else if(!/[^0-9]/.test(text)) { // all digits:
    return Number(text);
  } else if(String(Number(text)) === text) {
    return Number(text);
  } else {

    // complex expressions:

    // NOTE: there's an important distinction between converting primitive declarations to numbers,
    // and converting odds declarations to numbers. We only convert primitive declarations to
    // numbers if Number.toString() would return the same string anyway. On the other hand, odds
    // declarations can contain strings with math symbols
    let evaluatedText = __evaluateText(rootNode, thisRef, text);

    if(evaluatedText === "false") evaluatedText = "0";
    else if(evaluatedText === "true") evaluatedText = "1";

    // TODO: check that this works
    if(/[^0-9\/*&|%!.\(\)e\-]/.test(evaluatedText)) {
      __perchanceError(`Your odds declaration: "<b>${__escapeHTMLSpecialChars(text)}</b>", evaluated to: "<b>${__escapeHTMLSpecialChars(evaluatedText)}</b>" which contains characters that aren't allowed in odds declarations. The text after the "^" character defines the chance that that item will be selected (the higher the number the greater the chance). Odds declarations should only contain numbers, mathematical/logical operators, and are also allowed to have curly and square bracket blocks which will evaluate to number characters (these will be computed on-the-fly). If you'd like to use the "^" character literally (i.e. not to declare odds), you need to put a backslash character before it like so: "\\^"`);
      return false;
    }
    let num = false;
    try { num = eval(evaluatedText); } catch(e) {/* no need to catch */}
    return num;

  }

}

function __splitTextAtSquareBlocks(text, ctxInfo={}) {

  if(!text.includes("[") && !text.includes("]")) return [text];

  let escaped = false;
  let unclosedBracketCount = 0;
  let inJSExpr = false;
  let inJSExprString1 = false, inJSExprString2 = false, inJSExprString3 = false;
  let expressionArray = [];
  for(let i = 0; i < text.length; i++) {
    if(i !== 0) {
      if(text[i-1] !== "\\") { escaped = false; }
    }
    if(text[i] === "\\") { escaped = !escaped; }

    // skip strings in js expressions (square brackets in strings would mess
    // with our unclosedBracketCount):
    if(inJSExpr && !inJSExprString1 && !escaped && text[i] === "\"") { inJSExprString1 = true; continue; }
    if(inJSExprString1 && !escaped && text[i] !== "\"") { continue; }
    if(inJSExprString1 && !escaped && text[i] === "\"") { inJSExprString1 = false; continue; }

    if(inJSExpr && !inJSExprString2 && !escaped && text[i] === "'") { inJSExprString2 = true; continue; }
    if(inJSExprString2 && !escaped && text[i] !== "'") { continue; }
    if(inJSExprString2 && !escaped && text[i] === "'") { inJSExprString2 = false; continue; }

    if(inJSExpr && !inJSExprString3 && !escaped && text[i] === "`") { inJSExprString3 = true; continue; }
    if(inJSExprString3 && !escaped && text[i] !== "`") { continue; }
    if(inJSExprString3 && !escaped && text[i] === "`") { inJSExprString3 = false; continue; }

    // skip escaped brackets within js expressions (i.e. within regex declarations):
    if(inJSExpr && escaped && (text[i] === "[" || text[i] === "]")) { continue; }

    if(!escaped && text[i] === "[") {
      unclosedBracketCount++;
      // if we weren't already inJSExpr, then this is the start of the a JSExpr:
      if(!inJSExpr && i !== 0) {
        expressionArray.push(text.substr(0, i));
        text = text.substr(i);
        i = 0; // will be incremented to 0 on next loop, as required (we've already processed the first char, "[")
      }
      inJSExpr = true;
      continue;
    }

    if(!escaped && text[i] === "]") {
      unclosedBracketCount--;
      // we're only out of the js expression when we've closed all brackets
      if(inJSExpr && unclosedBracketCount === 0) {
        inJSExpr = false;
        expressionArray.push(text.substr(0, i+1));
        text = text.substr(i+1);
        i = -1; // will be incremented to 0 on next loop as required (we haven't yet processed the first character of the new string (the character after "]"))
      }
    }

    // last expression:
    if(i === text.length-1 && text.length !== 0) {
      expressionArray.push(text);
    }
  }

  if(unclosedBracketCount !== 0) {
    __perchanceError(`It appears that you've got a <b>mismatch in your opening and closing square brackets</b>${ctxInfo.declarationLineNumber ? ` on <b>line number ${ctxInfo.declarationLineNumber}</b>` : ""}. For each opening square bracket, there should be a closing one. If you'd like to use a <i>literal</i> square bracket (i.e. you want to actually display one, rather than using them to output a random list item, then you need to put a "backslash" before it like so: "\\[". Here's the text that seems to be causing the error: <blockquote>${__escapeHTMLSpecialChars(text)}</blockquote>`);
    return false;
  }

  return expressionArray;

}


function __getInlineFunctionDetails(lineText) {
  let escaped = false;
  let openIndex, opened = false;
  let closeIndex, closed = false;
  for(let i = 0; i < lineText.length; i++) {
    if(i !== 0) {
      if(lineText[i-1] !== "\\") { escaped = false; }
    }
    if(lineText[i] === "\\") { escaped = !escaped; }
    if(lineText[i] === "(" && !escaped) { opened = true; openIndex = i; }
    if(lineText[i] === ")" && !escaped && opened) { closed = true; closeIndex = i; }
    if(lineText[i] === "=" && !escaped && opened && closed && lineText[i+1] === ">") {
      let argString = lineText.substr(openIndex+1, closeIndex-openIndex-1);
      let args = argString.split(",").map(a => a.trim());
      let name = lineText.substr(0, openIndex).trim();
      let body = lineText.substr(i+2).trim();
      if(name.trim() === "") { return false; }
      if(body.trim() === "") { return false; }
      if(__areValidFunctionArguments(args) || argString === "") {
        if(!__isValidJavaScriptIdentifier(name)) return false;
        args = args.filter(a => a !== ""); // for zero arg case
        return { args, name, body };
      }
    }
  }
  return false;
}


function __getFunctionHeaderDetails(lineText) {
  lineText = lineText.trim();
  let l = lineText.length;
  if(lineText[l-2] === "=" && lineText[l-1] === ">") {
    lineText = lineText.substr(0, l-2).trim();
    l = lineText.length;
  } else {
    return false;
  }

  let escaped = false;
  let opened = false;
  let openIndex;
  for(let i = 0; i < lineText.length; i++) {
    if(i !== 0) {
      if(lineText[i-1] !== "\\") { escaped = false; }
    }
    if(lineText[i] === "\\") { escaped = !escaped; }
    if(lineText[i] === "(" && !escaped) { opened = true; openIndex = i; }
    if(lineText[i] === ")" && !escaped && opened) {
      let argString = lineText.substr(openIndex+1, i-openIndex-1);
      let args = argString.split(",").map(a => a.trim());
      let name = lineText.substr(0, openIndex).trim();
      if(name.trim() === "") { return false; }
      if(__areValidFunctionArguments(args) || argString === "") {
        if(!__isValidJavaScriptIdentifier(name)) return false;
        args = args.filter(a => a !== ""); // for zero arg case
        return { args, name };
      }
    }
  }
  return false;
}

function __areValidFunctionArguments(args) {
  for(let a of args) {
    if(!__isValidJavaScriptIdentifier(a.replace("...","").replace("=",""))) {
      return false;
    }
  }
  return true;
}

function __isValidJavaScriptIdentifier(str) {
  return /^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|null|this|true|void|with|await|break|catch|class|const|false|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)(?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D])(?:[\$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF])*$/.test(str);
}

function __getPrimitiveNodeDetails(lineText) {
  // NOTE: this function interprets some strings as numbers and casts them using Number()
  //       note that this is *just a shorthand*. The reason it's okay to do is because it
  //       only interprets strings as numbers if Number(that_number).toString() would return
  //       the same string anyway. If the user wants to do something like:
  //            prop = [this.age]/[this.height]
  //       then they should do this instead:
  //            prop = [this.age/this.height]
  //       because the prior will return something like "10/140" (i.e. a string, rather than a number)

  // remember: the lineText could have square blocks which can of course have equals signs in them.
  // But since primitive node keys can't be dynamic we can just return false if we see an unescaped square
  // or curly bracket before we find an unescaped equals sign

  let escaped = false;
  for(let i = 0; i < lineText.length; i++) {
    if(i !== 0) {
      if(lineText[i-1] !== "\\") { escaped = false; }
    }
    if(lineText[i] === "\\") { escaped = !escaped; }

    if((lineText[i] === "[" || lineText[i] === "{") && !escaped) {
      // found square or curly block before unescaped equals sign, so it's not a primitive node
      return false;
    }

    if(lineText[i] === "=" && !escaped) {
      let key = lineText.substr(0, i).trim();
      let valueText = lineText.substr(i+1).trim();
      if(key === "" || valueText === "") {
        return false;
      }

      let value;
      if(valueText === String(Number(valueText))) {
        value = Number(valueText);
      } else if(valueText === "true") { // TODO: test that this works (with filter/where, etc.)
        value = true;
      } else if(valueText === "false") {
        value = false;
      } else {
        value = valueText;
      }

      return {key, value};

    }
  }
  return false;
}

// function isMostLikelyAnIntentionalNumericString(valueText) {
//   if(isNaN(valueText)) { return false; }
//   if(/[^0-9.\-]+/.test(valueText)) { return false; }
//   if(valueText.split("-").length > 2) { return false; }
//   if(valueText.split(".").length > 2) { return false; }
//
//   if(valueText.split("-").length === 2) {
//     if(valueText[0] !== "-") { return false; }
//     if(valueText[0] === "-" && valueText[1] === ".") { return false; }
//   }
//
//   if(valueText.split(".").length === 2) {
//     if(valueText[0] === ".") { return false; }
//     if(valueText[valueText.length-1] === ".") { return false; }
//
//     let beforeDecimal = valueText.split(".")[0];
//     let afterDecimal = valueText.split(".")[1];
//     if(afterDecimal[afterDecimal.length-1] === "0") { return false; } // e.g. 20.0 shouldn't be treated as a number (they'd have just put in "20")
//     if(beforeDecimal[0] === "0" && beforeDecimal.length > 1) { return false; } // e.g. 020 shouldn't be treated as a number
//   }
//
//   return true;
//
// }


function __splitTextAtCurlyBlocks(text, ctxInfo={}) {
  // remember: we must ignore curly brackets if we're inside a js expression

  if(!text.includes("{") && !text.includes("}")) return [text];

  let escaped = false;
  let lastCurlyOpenIndex = null;

  let inJSExpr = false;
  let unclosedSquareBracketCount = 0;
  let inJSExprString1 = false;
  let inJSExprString2 = false;
  let inJSExprString3 = false;

  let inCurlyExpr = false;
  let unclosedCurlyBracketCount = 0;

  let blocks = [];

  for(let i = 0; i < text.length; i++) {
    if(i !== 0) {
      if(text[i-1] !== "\\") { escaped = false; }
    }
    if(text[i] === "\\") { escaped = !escaped; }

    ////////////////////////////////////
    // skip strings in js expressions //
    ////////////////////////////////////
    //(square brackets in strings would mess with our unclosedSquareBracketCount which we use to skip js expressions):
    if(inJSExpr && !inJSExprString1 && !escaped && text[i] === "\"") { inJSExprString1 = true; continue; }
    if(inJSExprString1 && !escaped && text[i] !== "\"") { continue; }
    if(inJSExprString1 && !escaped && text[i] === "\"") { inJSExprString1 = false; continue; }

    if(inJSExpr && !inJSExprString2 && !escaped && text[i] === "'") { inJSExprString2 = true; continue; }
    if(inJSExprString2 && !escaped && text[i] !== "'") { continue; }
    if(inJSExprString2 && !escaped && text[i] === "'") { inJSExprString2 = false; continue; }

    if(inJSExpr && !inJSExprString3 && !escaped && text[i] === "`") { inJSExprString3 = true; continue; }
    if(inJSExprString3 && !escaped && text[i] !== "`") { continue; }
    if(inJSExprString3 && !escaped && text[i] === "`") { inJSExprString3 = false; continue; }

    // skip escaped brackets within js expressions (i.e. escaped brackets within regex declarations):
    if(inJSExpr && /*--->*/escaped/*<---*/ && (text[i] === "[" || text[i] === "]")) { continue; }

    /////////////////////////////////////
    //      skip JS expressions        //
    /////////////////////////////////////
    // note that we're guarunteed to NOT be in a string for this block (since the
    // above block skips strings while we're in js expressions)
    if(!inJSExpr && text[i] === "[" && !escaped) {
      inJSExpr = true;
      unclosedSquareBracketCount++;
      continue;
    }
    if(inJSExpr && text[i] === "[") { // `escaped` is irrelevant, we're inJSExpr and not in string
      unclosedSquareBracketCount++;
      continue;
    }
    if(inJSExpr && text[i] === "]") { // `escaped` is irrelevant, we're inJSExpr and not in string
      unclosedSquareBracketCount--;
      if(unclosedSquareBracketCount === 0) { inJSExpr = false; }
    }


    //////////////////////////////////////
    //      extract curly blocks        //
    //////////////////////////////////////
    if(text[i] === "{" && !escaped && !inJSExpr) {
      unclosedCurlyBracketCount++;
      // if we're not yet in a curly expression, then this is the start of one:
      if(!inCurlyExpr && i !== 0) {
        blocks.push(text.substr(0, i));
        text = text.substr(i);
        i = 0;
      }
      inCurlyExpr = true;
      continue;
    }
    if(text[i] === "}" && !escaped && !inJSExpr) {
      unclosedCurlyBracketCount--;
      // we're only out of the curly expression when we've closed all curly brackets that were opened
      if(inCurlyExpr && unclosedCurlyBracketCount === 0) {
        blocks.push(text.substr(0, i+1));
        text = text.substr(i+1);
        i = -1;
        inCurlyExpr = false;
      }
    }

    // add last expression (if it didn't end in a curly block - in that case text.length === 0)
    if(i === text.length-1 && text.length !== 0) {
      blocks.push(text);
    }

  }

  if(unclosedSquareBracketCount !== 0) {
    __perchanceError(`It appears that you've got <b>a mismatch in your opening and closing square brackets</b>${ctxInfo.declarationLineNumber ? ` on <b>line number ${ctxInfo.declarationLineNumber}</b>` : ""}. For each opening square bracket, there should be a closing one. If you'd like to use a <i>literal</i> square bracket (i.e. you want to actually display one, rather than using them to output a random list item, then you need to put a "backslash" before it like so: "\\[". Here's the text that seems to be causing the error: <blockquote>${__escapeHTMLSpecialChars(text)}</blockquote>`);
    return ["(syntax error)"];
  }

  if(unclosedCurlyBracketCount !== 0) {
    __perchanceError(`It appears that you've got <b>a mismatch in your opening and closing curly brackets</b>${ctxInfo.declarationLineNumber ? ` on <b>line number ${ctxInfo.declarationLineNumber}</b>` : ""}. For each opening curly bracket, there should be a closing one. If you'd like to use a <i>literal</i> curly bracket (i.e. you want to actually display one, rather than using them to do {import:noun} and stuff like that, then you need to put a "backslash" before it like so: "\\{". Here's the text that seems to be causing the error: <blockquote>${__escapeHTMLSpecialChars(text)}</blockquote>`);
    return ["(syntax error)"];
  }


  return blocks;

}

function __splitTextAtAllBlocks(text, ctxInfo={}) {
  let curlySplitParts = __splitTextAtCurlyBlocks(text, ctxInfo);
  let blocks = []; // this array will contain curly blocks, text blocks, and square blocks
  for(let part of curlySplitParts) {
    if(part[0] !== "{") {
      let squareSplitParts = __splitTextAtSquareBlocks(part, ctxInfo);
      if(squareSplitParts) {
        blocks.push(...squareSplitParts);
      } else {
        console.error("Something is wrong?");
      }
    } else {
      blocks.push(part);
    }
  }
  return blocks;
}


function __stripCommentFromLine(line) {
  // NOTE: comment must either start at start of line, or have a space before it.
  // e.g. in http://example.com , "//example.com" isn't considered a comment because
  // it doesn't have a preceding space
  let i, escaped = false;
  for(i = 0; i < line.length; i++) {
    if(i !== 0) {
      if(line[i-1] !== "\\") { escaped = false; }
    }
    if(line[i] === "\\") { escaped = !escaped; }
    if(line[i] === "/" && !escaped && line[i+1] === "/") {
      if(i === 0) {
        break;
      } else {
        if(line[i-1] === " " || line[i-1] === "\t") {
          break;
        }
      }
    }
  }
  return line.substr(0,i);
}



function __normaliseLineIndentsToTabs(line) {
  let i, eqSpaceCount = 0; //equivalent spaces (1 tab = 2 spaces)
  for(i = 0; i < line.length; i++) {
    if(line[i] === " ") { eqSpaceCount++; }
    else if(line[i] === "\t") { eqSpaceCount += 2; }
    else { break; }
  }
  if(eqSpaceCount%2 !== 0) {
    return false; //odd number of spaces
  } else {
    return "\t".repeat(parseInt(eqSpaceCount/2)) + line.substr(i);
  }
}
