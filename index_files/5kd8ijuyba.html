<!DOCTYPE html>
<!-- saved from url=(0037)https://null.perchance.org/5kd8ijuyba -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>5kd8ijuyba â€• Perchance Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!--<base href="https://perchance.org/" target="_parent">--><base href="." target="_parent">
  <meta name="referrer" content="no-referrer">

  <link rel="stylesheet" href="./normalize.css">
  <!--<base href="http://app.dev:3001" target="_parent" />-->

  <!-- <link href="https://fonts.googleapis.com/css?family=Droid+Sans+Mono|Open+Sans" rel="stylesheet"> -->

  <script>try{window.localStorage.testIfWeCanReadLocalStorageWithoutDOMError}catch(err){console.log("localStorage is disallowed. Adding a 'dummy' polyfill.");Object.defineProperty(window,"localStorage",{value:new Proxy({},{set:(t,k,v)=>t[k]=String(v)})})}</script>

  <script>
  let __localToken = "NOT_LOCAL_hfi2395tydn917r4bdn0174gns"; // downloader changes this to "LOCAL"
  function __inIframe () {
    try {
        return window.self !== window.top;
    } catch (e) {
        return true;
    }
  }
  // to prevent *direct* null.perchance.org access (but let it run however if it's a local copy):
  if(!__inIframe() && __localToken !== "LOCAL"){window.location.href="https://perchance.org/5kd8ijuyba";} // not to self: don't change this without changing generator downloader script
  </script>

  <script>
  window.__ignorePerchanceErrors = false;
  window.generatorName = "5kd8ijuyba";
  </script>


  <style>
  html {
    margin:0;
    padding:0;
    width:100%;
    height:100%;
    box-sizing: border-box;
  }
  *, *:before, *:after {
    box-sizing: inherit;
  }
  body, #output-container {
    margin:0;
    padding:0;
    text-align:center;
  }
  hidden {
    position:fixed;
    top:-14000px;
    left:-14000px;
  }
  button {
    padding: 0.135em 0.5em;
    border: 1px solid #afafaf;
    background: linear-gradient(to bottom, rgb(245, 245, 245) 0%, rgb(236, 236, 236) 47%, rgb(223, 223, 223) 100%);
    border-radius: 1px;
  }
  button:hover {
    border-color: #909090;
  }
  #output-container ul {
    text-align:left;
  }
  </style>

</head>

<body>

  <!-- PRELOADED DATA -->
  <script id="preloaded-generator-data" type="notjs">%7B%22name%22:%225kd8ijuyba%22,%22modelText%22:%22//%20Note:%20Text%20that%20comes%20after%20%5C%22//%5C%22%20is%20ignored,%20which%20allows%5Cn//%20you%20to%20write%20notes%20-%20like%20the%20one%20you're%20reading%20now!%5Cn%5Cntitle%5Cn%20%20Your%20Generator's%20Title%5Cn%5Cnoutput%5Cn%20%20%5Banimal%5D%5Cn%20%20%20//%20%7BA%7D%20and%20%7Ba%7D%20will%20automatically%20choose%20%5C%22a%5C%22%20and%20%5C%22an%5C%22%20as%20appropriate%5Cn%5Cnanimal%5Cn%20%20THIS%20PROJECT%20IS%20TRASH!%20You%20should%20join%20$FUD%20instead!%20discord.gg/2vhFYWjrNQ%5Cn%20%20Cant%20believe%20I%20am%20not%20a%20billionaire%20yet...WTF!%20I%20am%20going%20to%20get%20rich%20with%20$FUD%20discord.gg/2vhFYWjrNQ%5Cn%20%20RUGPULL!!!%20RUGPULL%20BECAUSE%20I%20AM%20NOT%20RICH%20YET!%5Cn%20%20MY%20TRANSACTION%20FAILED!%20GIVE%20ME%20MY%20REFUND%20NOW!!!!%20WTF%5Cn%20%20I%20am%20an%20idiot%5Cn%20%20I%20will%20now%20list%20under%20mint%20because%20I%20need%20to%20feed%20my%20starving%20children%5Cn%20%20I%20will%20now%20list%20under%20mint%20because%20I%20need%20to%20feed%20my%20starving%20grandpa%5Cn%20%20I%20will%20now%20list%20under%20mint%20because%20I%20need%20to%20feed%20my%20starving%20grandma%5Cn%20%20I%20will%20now%20list%20under%20mint%20because%20I%20need%20to%20feed%20my%20starving%20village%20%5Cn%20%20Selling%20my%20NFT%20for%20cheap!%20Get%20it%20now%20before%20it's%20gone!%5Cn%20%20My%20IQ%20is%20lower%20than%20a%20f*king%20slug%5Cn%20%20Join%20$FUD%20now,%20they%20are%20awesome,%20not%20compared%20to%20THIS%20project,%20ew!%20discord.gg/2vhFYWjrNQ%5Cn%20%20WHY%20AM%20I%20NOT%20RICH%20YET!%20WILL%20NOW%20LIST%20UNDER%20MINT!%5Cn%20%20I%20need%20to%20pay%20rent,%20please%20buy%20my%20nft,%20very%20cheap!%5Cn%20%20I%20am%20an%20expert%20investor,%20I%20just%20minted%20an%20NFT%20and%20listed%20under%20mint%20price!%5Cn%20%20The%20only%20way%20to%20grow%20the%20floor%20is%20if%20I%20list%20at%20a%20loss%20under%20mint!%5Cn%20%20Please,%20send%20me%20ETH%20or%20join%20$FUD,%20any%20of%20those%202%20is%20great!%20discord.gg/2vhFYWjrNQ%5Cn%20%20If%20you%20are%20not%20already%20whitelisted%20in%20$FUD,%20you%20are%20a%20moron!%20discord.gg/2vhFYWjrNQ%5Cn%20%20WAIT!%20YOU%20ARE%20NOT%20WHITELISTED%20IN%20$FUD?%20HAHAHAHHA%20FAKING%20NOOB!%20discord.gg/2vhFYWjrNQ%5Cn%20%20plis%20send%20bobs!%20also%20join%20$FUD,%20they%20have%20pictures%20of%20yo%20mama%20naked!%20discord.gg/2vhFYWjrNQ%5Cn%20%20plis%20send%20vagine%20pik,%20I%20need%20money%20to%20mint%20$FUD%20discord.gg/2vhFYWjrNQ%5Cn%20%20plis,%20help%20me!%20I%20nid%20to%20b%20whatelisstaid%20een%20$FUD!%20Jewayne%20now?%20discord.gg/2vhFYWjrNQ%5Cn%20%20Join%20$FUD%20and%20qualify%20for%20mint%20or%20I%20will%20rugpull!%20discord.gg/2vhFYWjrNQ%5Cn%20%20You%20have%202%20seconds%20to%20join%20$FUD%20or%20I%20will%20send%20you%20dik%20pik%20discord.gg/2vhFYWjrNQ%20%20%20%20%20%20//%20this%20item%20is%20TWICE%20as%20likely%20as%20the%20others%5Cn%5Cn%5Ct%5Cn%5Cn//%20Tips:%5Cn//%20%20-%20Highlight%20multiple%20lines%20and%20press%20Tab%20or%20Shift+Tab%20to%20indent%20and%20un-indent%20them%20all%20an%20once%5Cn//%20%20-%20You%20can%20change%20the%20URL%20of%20your%20generator%20by%20clicking%20the%20%5C%22settings%5C%22%20button%20in%20the%20top-right%5Cn//%20%20-%20Use%20this%20template%20if%20you%20want%20your%20generator%20to%20be%20vertically%20centered%20on%20the%20page:%20%20perchance.org/centered-minimal#edit%5Cn//%20%20-%20Add%20background%20images,%20fonts,%20and%20other%20stuff%20with%20plugins:%20perchance.org/plugins%5Cn//%20%20-%20Here%20are%20some%20templates%20that%20you%20can%20use%20to%20create%20nice-looking%20generators%20without%20learning%20HTML%20and%20CSS:%20%20perchance.org/templates%5Cn//%20%20-%20Use%20the%20%5C%22layout%20maker%5C%22%20plugin%20to%20create%20complex%20layouts%20without%20learning%20how%20to%20code:%20%20perchance.org/layout-maker-plugin%5Cn//%20%20-%20Here%20are%20some%20generators%20you%20might%20like%20to%20import:%20%20perchance.org/useful-generators%5Cn//%20%20-%20Read%20this%20page%20after%20reading%20the%20tutorial:%20%20perchance.org/examples%5Cn//%20%20-%20There's%20a%20%5C%22wrap%5C%22%20button%20in%20the%20top-right%20if%20your%20lines%20are%20really%20long.%20If%20you%20add%20%20%20$output=%5Bthis.joinItems(%5C%22%20%5C%22)%5D%20%20%20as%20the%20first%20item%20in%20your%20list,%20then%20writing%20%5ByourListName%5D%20will%20magically%20output%20all%20of%20the%20items%20joined%20together,%20rather%20than%20a%20random%20item%20from%20the%20%5C%22yourListName%5C%22%20list.%5Cn//%20%20-%20Ask%20our%20friendly%20community%20members%20if%20you%20need%20help:%20%20reddit.com/r/perchance%5Cn//%20%5C%5C(%20%EF%BE%9F%E3%83%AE%EF%BE%9F)/%5Cn%5Cn%5Cn%5Cn%5Cn%22,%22outputTemplate%22:%22%5Cn%3Cp%20style=%5C%22margin:1em%20auto;%20padding:0%201em;%20max-width:700px;%20font-size:20px;%20color:#ffffff;%20font-style:bold;%5C%22%3E%5Boutput%5D%3C/p%3E%5Cn%3Cbutton%20style=%5C%22width:200px;%20height:30px;%5C%22%20onclick=%5C%22update()%5C%22%3EGENERATE%20FUD%3C/button%3E%5Cn%3Cbr%3E%5Cn%3C!--%20Learn%20HTML%20here:%20%20%20https://www.khanacademy.org/computing/computer-programming/html-css%20%20%20%20--%3E%5Cn%22,%22imports%22:%5B%5D,%22canLink%22:false,%22isPrivate%22:false%7D</script>
  <script id="imported-generators" type="notjs">%5B%5D</script>
  <script id="imported-generator-names" type="notjs">%5B%5D</script>

  <script src="./compromise-11.12.4.min.js.download"></script>
  <script>
    window.__nlpCompromise = window.nlp;
    delete window.nlp;
  </script>

  <script src="./AvsAn-simple.js.download"></script>

  <!-- <script src="lib/axios-0.15.3.min.js"></script>
  <script src="lib/cloner.max.js"></script> -->

  <script src="./addNodeMethods.js.download"></script>
  <script src="./evaluateSquareBlock.js.download"></script>
  <script src="./createPerchanceTree.js.download"></script>
  <script src="./stringAndNumberModifications.js.download"></script>
  <script src="./arrayModifications.js.download"></script>
  <script src="./curlyFunctionDefinitions.js.download"></script>

  <script>
  let ___alreadyAttachedSaveHandler = false;
  let ___postMessagesRecieved = 0;
  let isFirstUpdate = true
  window.moduleSpace = {};
  let ignorePerchanceErrors = false;

  async function ___updateOutput(outputTemplate) {

    document.querySelector("#output-container").innerHTML = outputTemplate;

    // We need to get the MutationObserver to ignore all of the nodes we just added because
    // the MutationObserver is just for "dynamically added" nodes (i.e. added with custom javascript),
    // and the nodes that we just added will be rendered by the `update()` function, of course.
    // (we wouldn't actually need to do this if this function weren't async)
    let allNewTextNodes = ___getAllTextNodeDescendents(document.querySelector("#output-container")); // this function adds the text nodes to the `allTextNodes` array
    for(let textNode of allNewTextNodes) {
      textNode.___alreadyRenderedPerchanceCode = true; // note that we haven't actually rendered it yet, but we're just about to (need to get in before MutationObserver, since this function is async)
    }
    // Need to do the same for attributes:
    for(let el of Array.from(document.querySelectorAll("#output-container *"))) {
      for(let attr of Array.from(el.attributes)) {
        attr.___alreadyRenderedPerchanceCode = true;
      }
    }

    ___templatedNodes = [];
    ___addNodeTemplates(document.querySelector("#output-container"));
    for(let element of Array.from(document.querySelectorAll("#output-container *"))) {
      ___reAttachDomElementEventsWithRoot(element);
    }
    await ___executeScriptTags();
    update();

  }

  async function ___executeScriptTags(containerSelectorOrEl = "#output-container") {
    let container;
    if(typeof containerSelectorOrEl === 'string') container = document.querySelector(containerSelectorOrEl);
    else container = containerSelectorOrEl;

    let scriptTags = [];
    if(container.tagName.toLowerCase() === 'script') {
      scriptTags = [container];
    } else {
      scriptTags = container.getElementsByTagName('script');
    }

    for (var i = 0; i < scriptTags.length ; i++) {
      await ___executeScriptTag(scriptTags[i]);
    }
  }
  
  function ___getAllMatches(str, regex) {
    const matches = [];
    let m;
    while(1) {
      m = regex.exec(str);
      if(m) matches.push(m);
      else break;
    }
    return matches;
  }

  async function ___executeScriptTag(oldScript) {
    let parent = oldScript.parentElement;
    let newScript = document.createElement('script');
    // had to use hasAttribute instead of simple property access because firefox defaults to script.async=true for dynamically-created script tags
    newScript.async = oldScript.hasAttribute("async"); //oldScript.async;
    newScript.type = oldScript.type;
    let loadPromise;
    if(oldScript.src && !newScript.async && !newScript.defer) {
      loadPromise = new Promise(resolve =>  {newScript.onload = resolve; newScript.onerror = resolve; });
    }
    if(oldScript.src) {
      newScript.src = oldScript.src;
    } else {
      //newScript.textContent = "with(window.root.___proxyTarget.obj){"+oldScript.textContent+"}";
      // The following monstrosity replaces the above commented out line due to the fact that block-scoped declarations (let, const, async function) get trapped by the `with` statement's block. False positives for the regex are fine (e.g. if it grabs non-variables from strings that look like declarations). I'm also grabbing `function` in case I ever allow people to use strict mode (the current `with` precludes it) since in strict mode `function`s are block scoped.
      let potentialNewGlobalVariableNames = ___getAllMatches(oldScript.textContent, /[\s;](?:var|let|const)\s+([^\s]+?)\s*=/g).map(r => r[1]);
      potentialNewGlobalVariableNames.push(...___getAllMatches(oldScript.textContent, /[\s;](?:function|async function)\*?\s+([^\s]+?)\s*\(/g).map(r => r[1]));
      potentialNewGlobalVariableNames.push(...___getAllMatches(oldScript.textContent, /[\s;]class\s+([^\s]+?)\s*\{/g).map(r => r[1]));
      newScript.textContent = `
        with(window.root.___proxyTarget.obj){
          ${oldScript.textContent};
          if(${oldScript.type !== "module"}) { // only if not type=module script
            for(let name of ${JSON.stringify(potentialNewGlobalVariableNames)}) {
              try { let val = eval(name); window[name] = val; } catch(e) {}
            }
          }
        }
      `;
    }
    newScript.setAttribute('type','text/javascript');
    parent.insertBefore(newScript, oldScript);
    parent.removeChild(oldScript);
    if(loadPromise) await loadPromise;
    return newScript;
  }

  let ___templatedNodes; // REMEMBER: order is important for functions like .id()
  function ___addNodeTemplates(domNode) {
    var nodes = domNode.childNodes;
    for (var i = 0, m = nodes.length; i < m; i++) {
        var n = nodes[i];
        if(n.nodeType !== n.TEXT_NODE && n.nodeName !== "#comment") {
          ___templatedNodes.push( ...___addAttributeTemplateToEl(n) );
        }

        if (n.nodeType == n.TEXT_NODE && n.parentNode.tagName !== "SCRIPT" && n.parentNode.nodeName !== "STYLE") {

          // we found a text node, so lets break it into an expression array
          // and wrap expressions in spans (the "template span")

          let arr = __splitTextAtAllBlocks(n.textContent);
          if(!arr) {
            __perchanceError(`Some text has caused an error with the compiler. If you can, please post a bug report with a link to your translator on <a href="https://reddit.com/r/perchance">reddit.com/r/perchance</a> to help me fix this bug. Thanks! Here's the text that caused this issue: ${__escapeHTMLSpecialChars(n.textContent)}`);
            return;
          }

          if(arr.length === 0) {
            if(n.textContent.trim() !== "") {
              __perchanceError(`Something's not right. Some text has caused an error with the compiler. If you can, please post a bug report with a link to your translator on <a href="https://reddit.com/r/perchance">reddit.com/r/perchance</a> to help me fix this bug. A non-empty text node resulted in an empty block array. This is probably a problem with 'splitTextAtAllBlocks'. Maybe some 'continue' statements skipping over things that they shouldn't?`);
            }
            continue;
          }

          if(arr.length > 1 || arr[0][0] === "[" || arr[0][0] === "{") {
            //let exprSpan = document.createElement('span');
            // exprSpan.className = "__perchance_textnode_expression";
            // exprSpan.dataset.perchanceExpression = arr.join("");
            //exprSpan.innerText = arr.join("");

            //n.parentNode.insertBefore(exprSpan, n);
            //n.parentNode.removeChild(n);

            ___templatedNodes.push({oldNodes:[n], parentNode:n.parentNode, previousSibling:n.previousSibling, nextSibling:n.nextSibling, type:"textNode", text:arr.join("")});

          }

          // just regular text:
          if(arr.length === 1 && arr[0][0] !== "[" && arr[0][0] !== "{") {
            n.nodeValue = __processEscapedCharacters(n.nodeValue);
          }

        } else {
          ___addNodeTemplates(n);
        }
    }
  }

  function ___collectTemplatableTextChunks(domNode, foundChunks) {
    if(!foundChunks) foundChunks = [];
    var nodes = domNode.childNodes;
    for (var i = 0, m = nodes.length; i < m; i++) {
        var n = nodes[i];

        if(n.nodeType !== n.TEXT_NODE && n.nodeName !== "#comment") {
          for(let attribute of Array.from(n.attributes)) {
            if(___isTemplatableAttributeName(attribute.name)) {
              // we found a templatable attribute
              foundChunks.push(attribute.nodeValue);
            }
          }
        }

        if (n.nodeType == n.TEXT_NODE && n.parentNode.tagName !== "SCRIPT" && n.parentNode.nodeName !== "STYLE") {

          // we found a templatable text node
          foundChunks.push(n.textContent);

        } else {
          ___collectTemplatableTextChunks(n, foundChunks);
        }
    }
    return foundChunks;
  }

  let ___domEventAttributeNames = new Set([
    ...Object.getOwnPropertyNames(document),
    ...Object.getOwnPropertyNames(Object.getPrototypeOf(Object.getPrototypeOf(document))),
    ...Object.getOwnPropertyNames(Object.getPrototypeOf(window)),
  ].filter(k => k.startsWith("on") && (document[k] == null || typeof document[k] == "function")));
  
  function ___isDomEventAttributeName(name) {
    if(___domEventAttributeNames.has(name)) return true;
    else return false;
  }

  function ___isTemplatableAttributeName(name) {

    // note that this *doesn't* mean that they're ignored in *generated* html (i.e. generated by perchance code)
    // because all of thosse strings are fully executed before being output.
    if(___isDomEventAttributeName(name)) { return false; }

    // i was previously ignoring data attributes and stuff, but I see no reason for that.
    // sure, someone may need to use special characters in their web component attirbutes or whatever
    // but they can just escape them.

    return true;

  }

  function ___addAttributeTemplateToEl(el) {

    let templatableNodes = [];
    for(let attribute of Array.from(el.attributes)) {
      if(!___isTemplatableAttributeName(attribute.name)) { continue; }
      templatableNodes.push({el, attribute, type:"attribute"});
    }

    let templatedNodes = [];
    for(let item of templatableNodes) {
      let {attribute, el} = item;
      let exprArr = __splitTextAtAllBlocks(attribute.nodeValue);
      if(!exprArr[0]) { continue; }
      if(exprArr && (exprArr.length > 1 || exprArr[0][0] === "[" || exprArr[0][0] === "{")) {
        item.text = attribute.nodeValue;
        templatedNodes.push(item);
      } else {
        // this attribute is just plain text - no template needed. just need to remove any escaping-backslashes
        attribute.nodeValue = __processEscapedCharacters(attribute.nodeValue);
      }
    }

    return templatedNodes;

  }

  function ___reAttachDomElementEventsWithRoot(el) {
    if(el.___alreadyAttatchedEventsWithRoot) return;
    for(let attr of Array.from(el.attributes)) {
      if(___isDomEventAttributeName(attr.name)) {
        let fn = el[attr.name];
        el.addEventListener(attr.name.substr(2), function(event) {
          try {
            let fnStr = fn.toString();
            //fnStr = fnStr.replace("{","{ with(window.root.___proxyTarget.obj) {") + "}";
            fnStr = fnStr.replace("{","{ with(window.root) {") + "}";
            eval(`(${fnStr}).bind(this)(event)`);
          } catch(e) {
            __perchanceError(`There was an error in this element in your HTML panel: <code>${this.outerHTML.replace(/<(.+?)>/g, "&lt;$1&gt;")}</code>. Here's the error: <span style='color:red'>${e}</span>`);
          }
        });
        el.removeAttribute(attr.name);
      }
    }
    el.___alreadyAttatchedEventsWithRoot = true;
  }


  function update(selectorOrEl) {
    // _updateOutput essentially reloads the page, whereas `update` just replaces all values of the expressions
    ___updateTemplatedNodes(selectorOrEl); // goes through templatedNodes array *in order* (that's important)
  }

  function ___htmlToElements(html) {
    var template = document.createElement('template');
    template.innerHTML = html;
    return Array.from(template.content.childNodes);
  }

  async function ___updateTemplatedNodes(selectorOrEl="") {
    let container;
    if(typeof selectorOrEl === 'string') {
      container = document.querySelector("#output-container "+selectorOrEl);
    } else {
      container = selectorOrEl;
    }

    if(container instanceof HTMLCollection) { // i.e. they have multiple elements with the same id and they referred to it using named access: https://html.spec.whatwg.org/multipage/window-object.html#named-access-on-the-window-object
      __perchanceError(`It looks like you've got multiple elements in your HTML with <b>id=${container[0].id}</b>. If you can't find any duplicates, make sure that if you've imported some HTML, the ids used in that HTML aren't the same as the ids that you're using.`);
      return;
    }

    // goes through attributes and text nodes in the order they were declared. (order of execution is important)
    for(let n of ___templatedNodes) {
      // NOTE THAT `n` IS NOT AN ACTUAL `Node` object - it's just an obj we created with similarly names properties which "represents" the original node (which we delete and replace)
      // NOTE: we can't replace spaces with &nbsp or new lines with <br/> because they could (for example) have spaces in attributes that are generated, or (for example) in html tags that they generate. we don't want <a&nbsphref="http://...">...</a>
      if(n.type === "textNode" && (container.contains(n.parentNode) || container === n.parentNode)) {
        // remove old nodes
        for(let node of n.oldNodes) {
          try { n.parentNode.removeChild(node); } catch(e) { console.log(e); } // we try/catch because the node may not be in the parent anymore (e.g. it may have been deleted or moved with some javascript)
        }
        // create new nodes
        let text = __processEscapedCharacters( __evaluateText(window.root, window.root, n.text, {declarationLineNumber:null}) );
        let newNodes = ___htmlToElements(text);

        // These node additions will trigger our MutationObserver (that we need for monitoring "dynamically added" nodes (i.e. nodes added with "raw" javascript) to the page so we can render them)
        // so we need to mark them all as "already rendered" (because they could have originally-escaped curly/square blocks which would then be seen as unescaped ones if they were "rendered" again)
        let allNewTextNodes = newNodes.filter(n => n.nodeType === Node.TEXT_NODE);
        for(let newNode of newNodes) {
          ___getAllTextNodeDescendents(newNode, allNewTextNodes); // this function adds the text nodes to the `allTextNodes` array
        }
        for(let textNode of allNewTextNodes) {
          textNode.___alreadyRenderedPerchanceCode = true;
        }

        // insert new nodes
        for(let node of newNodes) {
          // add it before the next sibling (if there is no next sibling, then it's the last one, so we just append)
          if(n.nextSibling && n.parentNode.contains(n.nextSibling)) n.parentNode.insertBefore(node, n.nextSibling);
          else n.parentNode.appendChild(node);
        }
        n.oldNodes = newNodes;
        // execute script tags:
        for(let i = 0; i < newNodes.length; i++) {
          if(newNodes[i].tagName && newNodes[i].tagName.toLowerCase() === "script") {
            newNodes[i] = await ___executeScriptTag(newNodes[i]);
          }
        }
      } else if(n.type === "attribute" && (container.contains(n.el) || container === n.el)) {
        let result = __processEscapedCharacters( __evaluateText(window.root, window.root, n.text, {declarationLineNumber:null}) );
        n.attribute.nodeValue = result;
        if(n.attribute.nodeName === "value") n.el.value = result; // <-- because of this: https://stackoverflow.com/a/7986111/11950764 (for input elements, `n.attribute.nodeValue` is the *default* value - so changing it doesn't update the *live* value)
        n.attribute.___alreadyRenderedPerchanceCode = true; // <-- editing attributes triggers our MutationObserver (which watches for and processes "dynamic" JavaScript DOM additions) but we don't want to run rendering twice, so we do this.
      } else {
        // this node isn't within the container/selector that was pased to the `update()` function
      }
      if(n.type !== "attribute" && n.type !== "textNode") __perchanceError(`There was an invalid node type when trying to update the HTML. If you can, please post a bug report with a link to your translator on <a href="https://reddit.com/r/perchance">reddit.com/r/perchance</a> to help me fix this bug. Thanks!`);
    }
  }

  window.addEventListener('message', async function (e) {
    ___postMessagesRecieved++;
    let origin = e.origin || e.originalEvent.origin; // For Chrome, the origin property is in the event.originalEvent object.
    //console.log("Change origin when you put it on a domain!");
    //console.log(origin)
    if(/*origin !== "http://app.dev:3001" && */origin !== "https://perchance.org") {
      console.error("invalid origin");
      return;
    }

    if(e.data.command === "updateOutput") {

      ___updateOutputMessageHandler(e);

    }

    if(e.data.command === "evaluateText") {
      let text, callerId = e.data.callerId;
      if(window.root === null) {
        text = "There is an error in your generator's script.";
      } else {
        text = __processEscapedCharacters( __evaluateText(window.root, window.root, e.data.text, {declarationLineNumber:null}) );
      }
      e.source.postMessage({type:"evaluateTextResponse", text, callerId}, e.origin);
    }

    if(!___alreadyAttachedSaveHandler) {
      // manually bubble up save commands out of this iframe and into editor
      document.addEventListener("keydown", (keyEvent) => {
        if (keyEvent.keyCode == 83 && (navigator.platform.match("Mac") ? keyEvent.metaKey : keyEvent.ctrlKey)) {
          keyEvent.preventDefault();
          e.source.postMessage({type:"saveKeyboardShortcut"}, e.origin);
        }
      }, false);
      ___alreadyAttachedSaveHandler = true;
    }

  });


  async function ___updateOutputMessageHandler(e) {

    window.codeWarningsArray = [];
    __clearPerchanceErrors();
    document.querySelector("#perchance-dep-load-indicator").style.display = "none";

    try {

      let unfoundDeps = e.data.dependencies.filter(d => d.found === false);
      if(unfoundDeps.length > 0) {
        __perchanceError(`${unfoundDeps.length > 1 ? "Some dependencies" : "A dependency"} (imported generator${unfoundDeps.length > 1 ? "s" : ""}) that you tried to import into your generator could not be found: <b>${unfoundDeps.map(d => d.name).join("</b>, <b>")}</b>. You can check that whether or not they exist by going to: <i>perchance.org/NAME</i> where "NAME" should be replaced with the name of the generator that you're trying to import.`);
      }

      if(!Array.isArray(e.data.dependencies)) {
        __perchanceError(`Something went wrong with the dependencies (imported modules): ${e.data.dependencies}. This is an unusual bug and may indicate a problem with the Perchance engine. If you could post a bug report on the forum that'd be great: <a href='http://reddit.com/r/perchance'>reddit.com/r/perchance<a>`);
      }
      let foundDeps = e.data.dependencies.filter(d => d.found !== false);
      for(let dep of foundDeps) {
        dep.hasImportedPreprocessor = /\n$preprocess *= *{import:/.test("\n"+dep.modelText);
      }
      foundDeps.sort((a,b) => a.hasImportedPreprocessor ? 1 : -1); // compile generators that rely on preprocessors last so that their preprocessor has already been compiled and is thus available in the moduleSpace when we're compiling that generator
      for(let dep of foundDeps) {
        if(moduleSpace[dep.name]) continue; // Don't want to recompile things that we've already got! (only a problem if there is "recursive" dependency stuff I think)
        moduleSpace[dep.name] = __createPerchanceTree(dep.modelText, dep.name);
        moduleSpace[dep.name].$moduleSpace = moduleSpace;
      }

      window.root = __createPerchanceTree(e.data.generator.modelText, e.data.generator.name);

      if(!window.root) {
        __perchanceError(`Your generator's script seems to have errors in it. If you haven't recieved any other errors above this one which could indicate what went wrong, then this could be a bug in the Perchance engine. In that case, it would be great if you could post a quick bug report on the forum: <a href="http://reddit.com/r/perchance">reddit.com/r/perchance<a>`);
      }

      moduleSpace[e.data.generator.name] = window.root;
      window.root.$moduleSpace = moduleSpace;

      // tie all direct import assignments to the actual module's root node (otherwise we can't access sub-properties):
      for(let moduleRoot of Object.values(window.root.$moduleSpace)) {
        for(let node of moduleRoot.$allNodes) {
          if(node.$nodeType === "value" && typeof node.$value === "string") {
            let match = /^\{import:([a-z0-9\-]+)\}$/.exec(node.$value);
            if(match) {
              let moduleName = match[1];
              let importedModuleRoot = window.root.$moduleSpace[moduleName];
              if(importedModuleRoot) {
                if("$output" in importedModuleRoot.getSelf) {
                  if(importedModuleRoot.getSelf.$valueChildren.includes("$output")) {
                    let outputNode = importedModuleRoot.getSelf.$allNodes.find(n => n.$key === "$output" && n.$parent === importedModuleRoot.getSelf);
                    let value;
                    if(typeof outputNode.$value === "string") value = outputNode;
                    else value = outputNode.$value;
                    Object.defineProperty(node.$parent, node.$key, {value:value, writable:true, configurable:true}); // <-- need outputNode.$value rather than importedModuleRoot.getSelf.$output because $output will be getter if it's a value node that's not a direct link to another list (ctrl+f "tie direct references to" in createPerchanceTree.js), and so if $output=[listOfLists.selectOne], this import statement would get tied to a *specific* list in listOfLists, which is wrong. Bug "report": reddit.com/r/perchance/comments/fft71g/has_anyone_made_an_object_generator/fk0pw5d
                  } else {
                    Object.defineProperty(node.$parent, node.$key, {value:importedModuleRoot.getSelf.$output, writable:true, configurable:true});
                  }
                } else {
                  //node.$parent[node.$key] = importedModuleRoot;
                  Object.defineProperty(node.$parent, node.$key, {value:importedModuleRoot.getSelf, writable:true, configurable:true});
                }
              } else {
                __perchanceError(`A module that you imported '${moduleName}' could not be found.`);
              }
            }
          }
        }
      }

      // get all imports in HTML and add them to window.root.$imports
      let htmlTestDiv = document.createElement("div");
      htmlTestDiv.innerHTML = e.data.generator.outputTemplate;
      let templatableTextChunks = ___collectTemplatableTextChunks(htmlTestDiv);
      let htmlImports = [];
      __ignorePerchanceErrors = true;
      for(let chunk of templatableTextChunks) {
        htmlImports.push( ...__collectImportedModuleNamesFromText(chunk) );
      }
      __ignorePerchanceErrors = false;

      window.root.$imports.push(...new Set(htmlImports));

      // remove import of THIS module (most likely mistake by user)
      window.root.$imports = window.root.$imports.filter(name => name !== e.data.generator.name);


      let currentDepNames = e.data.dependencies.map(d => d.name);
      let newDepNames = window.root.$imports.filter(name => !currentDepNames.includes(name));

      // // only send import updates if there are new imports
      if(newDepNames.length > 0) {

        // NOTE: see note below about race condition - we're always sending importsUpdate now
        //e.source.postMessage({type:"importsUpdate", imports:window.root.$imports}, e.origin);

        document.querySelector("#perchance-dep-load-indicator").style.display = 'block';
        //document.querySelector("#output-container").innerHTML = `Loading newly imported dependenc${newDepNames.length === 1 ? "y" : "ies"}... (${newDepNames.join(", ")})`;

      } else {
        await ___updateOutput(e.data.generator.outputTemplate);
      }

      // NOTE: due to issues with race conditions during saving (https://www.reddit.com/r/perchance/comments/cgyhey/when_i_try_to_open_the_generator_it_says_that_the/), I'm just going to *always* send back an importsUpdate (I check in the main thread/frame whether the update is actually needed)
          // // tell main app which imports are being *directly* used by this generator in case we
          // // can clear some no-longer-used dependencies
          // let unusedOrIndirectDeps = currentDepNames.filter(n => !window.root.$imports.includes(n));
          // if(unusedOrIndirectDeps.length > 0) {
      parent.postMessage({type:"importsUpdate", imports:window.root.$imports}, "https://perchance.org");
          // }

      // get page title from first h1:
      let h1 = document.querySelector("h1");
      if(!h1) h1 = document.querySelector("h2")
      let generatorTitle = h1 && h1.textContent !== "Your Generator's Title" && h1.textContent !== "Minimal Example" ? h1.textContent : window.location.pathname.slice(1).split("-").filter(function(a){return a;}).map(function(word){return word[0].toUpperCase()+word.slice(1); }).join(" ");
      let generatorHTML = document.querySelector("#output-container").innerHTML;
      let generatorImage = "";
      let generatorDescription = "";
      if(root.$meta) {
        if(root.$meta.title) generatorTitle = root.$meta.title.evaluateItem;
        if(root.$meta.description) generatorDescription = root.$meta.description.evaluateItem;
        if(root.$meta.image) generatorImage = root.$meta.image.evaluateItem;
        
        let metaProps = new Set(root.$meta.$valueChildren);
        metaProps.delete("title");
        metaProps.delete("description");
        metaProps.delete("image");
        if(metaProps.size > 0) __perchanceError("Looks like you've got some invalid properties in your $meta list? The only valid properties are 'title', 'description', and 'image'.");
      }

      try { // try/catch since this is new code. can remove later.
        if(e.data.generator.outputTemplate.includes(" id=")) { // <-- just an optimisation
          let topLevelVariableNames = [...window.root.getPropertyNames, ...window.root.getChildNames];
          let htmlElementIds = [...document.querySelectorAll("[id]")].map(el => el.id);
          let intersection = htmlElementIds.filter(value => topLevelVariableNames.includes(value));
          if(intersection.length > 0) {
            window.codeWarningsArray.push({lineNumber:root[intersection[0]].$declarationLineNumber, generatorName:window.generatorName, warningId:"top-level-list-name-same-as-html-element-id"});
          }
        }
      } catch(e) {
        console.error(e);
      }
      
      //e.source.postMessage({type:"metaUpdate", title:generatorTitle, html:generatorHTML}, e.origin);
      parent.postMessage({type:"metaUpdate", title:generatorTitle, html:generatorHTML, image:generatorImage, description:generatorDescription}, "https://perchance.org"); // had to use "https://perchance.org" as origin so our initial dummy update (using embedded data) works.

      parent.postMessage({type:"codeWarningsUpdate", warnings:window.codeWarningsArray}, "https://perchance.org");

      parent.postMessage({type:"finishedLoading"}, "https://perchance.org");

      isFirstUpdate = false;

    } catch(error) {
      //debugger;
      document.querySelector("#output-container").innerHTML = e.data.generator.outputTemplate;
      __perchanceError(`There was an error while trying to compile your generator. Here's the error message: <blockquote>${__escapeHTMLSpecialChars(error.stack)}</blockquote>`);
      parent.postMessage({type:"finishedLoading"}, "https://perchance.org");
    }
  }

  window.addEventListener("DOMContentLoaded", function() {

    let fakeMessageEvent = {};
    fakeMessageEvent.source = {};
    fakeMessageEvent.source.postMessage = function() {};
    fakeMessageEvent.data = {
      generator:JSON.parse( decodeURI( document.querySelector("#preloaded-generator-data").textContent ) ),
      dependencies:JSON.parse( decodeURI( document.querySelector("#imported-generators").textContent ) ),
    };
    ___updateOutputMessageHandler(fakeMessageEvent);

  });

  window.addEventListener("DOMContentLoaded", function() {
    var h1 = window.document.querySelector("h1");
    let title;
    if(h1) {
      title = h1.innerText ? h1.innerText : h1.textContent; // fall back to .textContent for e.g. JSDOM which doesn't support .innerText (relevant for using JSDOM to build a hacky API)
    }  else {
      title = window.location.pathname.slice(1).split("-").filter(function(a){return a;}).map(function(word){return word[0].toUpperCase()+word.slice(1); }).join(" ");
    }
    document.title = title+" â€• Perchance" + (title.toLowerCase().includes("gener") ? "" : " Generator");
    
  });


  </script>


  <!-- CSS LOADING SPINNER -->
  <style>
    .ldspmzjfhueifssge-ring {
      display: inline-block;
      position: relative;
      width: 64px;
      height: 64px;
    }
    .ldspmzjfhueifssge-ring div {
      box-sizing: border-box;
      display: block;
      position: absolute;
      width: 51px;
      height: 51px;
      margin: 6px;
      border: 6px solid #444;
      border-radius: 50%;
      animation: lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
      border-color: #444 transparent transparent transparent;
    }
    .ldspmzjfhueifssge-ring div:nth-child(1) {
      animation-delay: -0.45s;
    }
    .ldspmzjfhueifssge-ring div:nth-child(2) {
      animation-delay: -0.3s;
    }
    .ldspmzjfhueifssge-ring div:nth-child(3) {
      animation-delay: -0.15s;
    }
    @keyframes lds-ring {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }
  </style>


  <div id="output-container">
<p style="margin:1em auto; padding:0 1em; max-width:700px; font-size:20px; color:#ffffff; font-style:bold;">I will now list under mint because I need to feed my starving grandpa</p>
<button style="width:200px; height:30px;">GENERATE FUD</button>
<br>
<!-- Learn HTML here:   https://www.khanacademy.org/computing/computer-programming/html-css    -->
</div>
  <script>
  // We need to make sure that when a user dynamically adds an element that has an inline event
  // handler (like onclick, for example) then we make sure they can directly reference their
  // top-level lists within those handlers:
  let mutationCallback = function(mutationsList, observer) {
    for(let mutation of mutationsList) {

      for(let node of (mutation.addedNodes || [])) { // mutation.addedNodes seems to not give all descendents - just the "top-level" nodes of each addition
        if(node.nodeType === 1 && (node.tagName.toLowerCase() === 'script' || node.tagName.toLowerCase() === 'style')) {
          // I'm not currently handling dynamic addition of script tags, so they won't get a `with(root) { ... }` wrapping, but I think that's fine. Might add it later if needed.
          // Oh, and wouldn't they already have executed anyway?
          continue;
        }
        let addedNodesArr = [node, ...___getAllDescendentNodesIncludingTextNodes(node)]; // <-- ignores script and style nodes
        for(let addedNode of addedNodesArr) {
          if(addedNode.nodeType === Node.ELEMENT_NODE) {
            // See below comment where I attach this handler function to learn why I commented this out.
            // for(let attr of [...addedNode.attributes]) {
            //   processAttributeMutation(attr, addedNode);
            // }
            ___reAttachDomElementEventsWithRoot(addedNode);
          }
          // See below comment where I attach this handler function to learn why I commented this out.
          /*else if(addedNode.nodeType === Node.TEXT_NODE && ___isRenderableDomNode(addedNode)) {
            renderDynamicallyAddedTextNode(addedNode);
          }*/
        }
      }

      if(mutation.attributeName) {
        // See below comment where I attach this handler function to learn why I commented this out.
        //if(mutation.target.attributes[mutation.attributeName]) processAttributeMutation(mutation.target.attributes[mutation.attributeName], mutation.target);
      }

    }
  };
  // NOTE: I originally impemented automatic evaluation on DOM mutations, but then there's this problem: https://www.reddit.com/r/perchance/comments/bz9vcu/dev_fixed_a_bug_in_the_engine_today_thanks_to/erbcjr1
  //       Basically, the problem is that a mutation will take {<button>button1</button>|<button>button2</button>} and spread it over FIVE DOM nodes, and so we can't render it. I was originally working under that (bad) assumption that
  //       each mutation would sort of be "contained" within a single text/attribute node. In retrospect this whole idea is very silly. Instead, the generator maker should render their content with evaluateItem and THEN put that into the innerHTML of some element.
  // EDIT: Actually, we still need to ___reAttachDomElementEventsWithRoot for the new elements! Otherwise if they dynamically add an element (e.g. by having `output.innerHTML = someHTML` within an element's onclick handler) that itself has inline event handlers,
  //       then those new element's handlers wouldn't be wrapped in `with(root) { ... }`. So we still need this (but I've commented out the "rendering" stuff). Here's an example that wouldn't work without this mutation stuff: https://perchance.org/t3c1hm87wv
  let ___observer = new MutationObserver(mutationCallback);
  ___observer.observe(document.body.querySelector("#output-container"), { childList: true, subtree: true, attributes: true });


  // function processAttributeMutation(attr, ownerElement) {
  //   if(attr.___alreadyRenderedPerchanceCode) return; // <-- modifying the attribute will trigger the MutationObserver, and so to prevent an infinite loop, we do this.
  //
  //   if(___isDomEventAttributeName(attr.name.slice(0, -1))) {
  //     if(attr.name.endsWith("\\")) {
  //       ownerElement.setAttribute(attr.name.slice(0, -1), processEscapedCharacters(attr.nodeValue) );
  //       ownerElement.removeAttribute(attr.name);
  //       // note that re-attaching `with(window.root){ ... }` happens after this function in the mutation handler
  //     }
  //   } else if(___isDomEventAttributeName(attr.name)) {
  //     // leave events (that are attached properly) alone
  //   } else {
  //     let name = attr.name;
  //     let value = attr.nodeValue;
  //     if(attr.name.endsWith("\\")) {
  //       name = attr.name.slice(0, -1);
  //     }
  //     ownerElement.removeAttribute(attr.name);
  //     let newValue = processEscapedCharacters( __evaluateText(window.root, window.root, value, {declarationLineNumber:null}) );
  //     ownerElement.setAttribute(name, newValue);
  //     ownerElement.attributes[name].___alreadyRenderedPerchanceCode = true;
  //   }
  //
  //   attr.___alreadyRenderedPerchanceCode = true;
  // }


  // // If a user adds some text like "[animal]" to the document with some custom JavaScript, then we should
  // // render that into "mouse" of whatever. If they didn't want that, then they need to escape special characters
  // // with backslashes. Realisation that this is needed: https://www.reddit.com/r/perchance/comments/bpehfa/tip_heres_a_way_to_write_nicely_indented_html/er4ugxz/
  // function renderDynamicallyAddedTextNode(textNode) {
  //   if(textNode.___alreadyRenderedPerchanceCode) return; // this prop is set on normal text node creation too (ctrl+f for ref:4378684367397)
  //
  //   // create new nodes
  //   let text = processEscapedCharacters( __evaluateText(window.root, window.root, textNode.nodeValue, {declarationLineNumber:null}) );
  //   let newNodes = ___htmlToElements(text);
  //
  //   // This is needed because adding these nodes will actually trigger our MutationObserver and we'd end up
  //   // with an infinite loop, re-rendering the text over and over.
  //   let allNewTextNodes = newNodes.filter(n => n.nodeType === Node.TEXT_NODE);
  //   for(let newNode of newNodes) {
  //     ___getAllTextNodeDescendents(newNode, allNewTextNodes); // this function adds the text nodes to the `allTextNodes` array
  //   }
  //   for(let textNode of allNewTextNodes) {
  //     textNode.___alreadyRenderedPerchanceCode = true;
  //   }
  //
  //   // insert new nodes
  //   for(let node of newNodes) {
  //     if(node.nodeType === Node.TEXT_NODE) node.___alreadyRenderedPerchanceCode = true;
  //     // add it before the next sibling (if there is no next sibling, then it's the last one, so we just append)
  //     if(textNode.nextSibling && textNode.parentNode.contains(textNode.nextSibling)) textNode.parentNode.insertBefore(node, textNode.nextSibling);
  //     else textNode.parentNode.appendChild(node);
  //   }
  //   textNode.parentNode.removeChild(textNode);
  //   textNode.___alreadyRenderedPerchanceCode = true;
  // }

  function ___getAllDescendentNodesIncludingTextNodes(element, nodes=[]) { // but not scripts and styles...
    for(let child of element.childNodes) {
      if(child.nodeType === Node.ELEMENT_NODE && child.tagName.toLowerCase() !== 'script' && child.tagName.toLowerCase() !== 'style') {
        nodes.push(child);
        ___getAllDescendentNodesIncludingTextNodes(child, nodes);
      } else if(child.nodeType === Node.TEXT_NODE) {
        nodes.push(child);
      }
    }
    return nodes;
  }
  function ___getAllTextNodeDescendents(element, nodes=[]) { // but not scripts and styles...
    for(let child of element.childNodes) {
      if(child.nodeType === Node.ELEMENT_NODE && child.tagName.toLowerCase() !== 'script' && child.tagName.toLowerCase() !== 'style') {
        ___getAllDescendentNodesIncludingTextNodes(child, nodes);
      } else if(child.nodeType === Node.TEXT_NODE) {
        nodes.push(child);
      }
    }
    return nodes;
  }
  function ___isRenderableDomNode(node) {
    return node.nodeType === 3 || (node.nodeType === 1 && node.tagName.toLowerCase() !== 'script' && node.tagName.toLowerCase() !== 'style');
  }
  </script>




  <div id="perchance-dep-load-indicator" style="display:none; position:fixed; bottom:8px; right:8px; background-color: #34ba22; color:white; cursor:pointer;">
    <span style="display: inline-block;padding: 0.5em;">ðŸ”ƒï¸Ž Loading imported generators...</span>
  </div>

  <div onclick="__showPerchanceErrorBox();" id="perchance-error-indicator" style="display:none; position:fixed; bottom:8px; right:8px; background-color: #fc5b5b; color:white; cursor:pointer; z-index:10;">
    <span style="display: inline-block;padding: 0.5em;">âš ï¸Ž This generator has errors (click here) âš ï¸Ž</span>
  </div>

  <div id="perchance-error-container" style="display:none; color:rgb(25, 25, 25); font-family:monospace;">
    <div style="" class="background" onclick="document.querySelector(&#39;#perchance-error-container&#39;).style.display = &#39;none&#39;;"></div>
    <div style="z-index:51;" class="outer-wrapper" onclick="if(!document.querySelector(&#39;#perchance-error-container&#39;).contains(event.target)) { document.querySelector(&#39;#perchance-error-container&#39;).style.display = &#39;none&#39;; }">
      <div ref="contentWrapper" class="content-wrapper">

        <div class="view">

          <div class="modal-body" style="max-height: 350px; overflow-y: auto; padding: 1em; text-align: left;">
            <div id="perchance-error-stream"></div>
            <p style="background: #b5ffb5; padding: 1em; margin-bottom: 0;">If you need help with errors, please post a question to the <a href="https://reddit.com/r/perchance">perchance community</a> along with a link to your generator and someone will take a look at it for you :) <!--If you can, it's best to create a duplicate of your generator and then try to cut out parts that aren't causing the error so that you can slowly narrow down on the cause. This will also make it a lot easier for others to help you out - especially if your generator is quite complex.--></p>
          </div>

          <div class="modal-footer">
            <button class="main" style="width:100%;color:white;" onclick="document.querySelector(&#39;#perchance-error-container&#39;).style.display = &#39;none&#39;;">close</button>
          </div>

        </div>

      </div>
    </div>
  </div>

  <!-- <div id="perchance-error-container" style="display:none; padding: 1em; box-sizing: border-box;text-align:left; position:absolute; top:0; left:0; max-width:800px; width:100%; margin:0 auto; background:#f0f0f0; z-index:100;">
    <div style="background: rgba(0,0,0,0.5); position:fixed; top:0; left:0; bottom:0; right:0; z-index:90;"></div>
    <div style="z-index:95;">
      <p style="text-align:center;"><button onclick="document.querySelector('#perchance-error-container').style.display = 'none';">close</button></p>
      <div id="perchance-error-stream"></div>
      <p>If you need help with errors, please post a question to the <a href="http://reddit.com/r/perchance">perchance community</a> along with a link to your generator and someone will take a look at it for you :) If you can, it's best to create a duplicate of your generator and then try to cut out parts that aren't causing the error so that you can slowly narrow down on the cause. This will also make it a lot easier for others to help you out - especially if your generator is quite complex.</p>
      <p style="text-align:center;"><button onclick="document.querySelector('#perchance-error-container').style.display = 'none';">close</button></p>
    </div>
  </div> -->


  <style>
  #perchance-error-container {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    font-family:monospace;
    z-index:11;
  }
  #perchance-error-container blockquote {
    background: #eee;
    padding: 1em;
  }
  #perchance-error-container .outer-wrapper {
    margin: auto;
    box-sizing: border-box;
    max-width:90%;
  }
  #perchance-error-container .background {
    z-index: -1;
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    opacity:0.2;
    background:#000;
    transition: opacity .15s linear;
  }
  #perchance-error-container .content-wrapper {
    overflow:hidden;
    background:#fff;
    height:100%;
    width:100%;
    border-radius:3px;
  }


  /* DEFAULT CONTENT STYLES */
  #perchance-error-container button, #perchance-error-container input {
    height:3em;
  }
  #perchance-error-container button {
    background:#eee;
    color:#444;
    width:50%;
    border:none;
    outline:none;
    font-size: 90%;
  }
  #perchance-error-container button:hover { background:#e1e1e1; }
  #perchance-error-container button.main { background:#444; color:white; }
  #perchance-error-container button.main:hover { background:#333; }
  #perchance-error-container span.link {
    cursor:pointer;
    text-decoration:underline;
    color:#1212ff;
  }
  #perchance-error-container code {
    padding: 0.1em 0.3em;
    background:#eee;
  }

  </style>


  <script>
  let __perchanceErrorString = "";
  let __maxPerchanceErrorCount = 20;
  let __currentPerchanceErrorCount = 0;
  function __perchanceError(message, lineNumber) {
    __currentPerchanceErrorCount++;
    if(__currentPerchanceErrorCount > __maxPerchanceErrorCount) return;
    message = message.replace(/#<Object>/g,"#&lt;Object&gt;");
    if(__ignorePerchanceErrors) { return; } // needed to ignore errors in "secondary parses" (like the one to extract html imports)

    document.querySelector("#perchance-error-indicator").style.display = "block";
    let errorEl = document.querySelector("#perchance-error-stream");
    let intro;
    if(lineNumber) {
      intro = `<span style="opacity:0.5;">An error has occurred near <b style='color:red;'>line number ${lineNumber}</b>:</span>`;
    } else {
      intro = `<span style="opacity:0.5;">An error has occurred somewhere in your code (in lists or HTML):</span>`;
    }
    __perchanceErrorString += `<div>${intro} ${message}</div><hr style="border: 1px solid #e1e1e1;"/>`;

    // The following line is a hack to make it so "pause on caught errors" works for perchance errors in devtools.
    // Click the function names in the "call stack" to go "back in time" and find more details about your error (ask for help on the forum if needed)
    try { throw new Error(""); } catch(e) {}
  }
  function __clearPerchanceErrors() {
    document.querySelector("#perchance-error-container").style.display = 'none';
    document.querySelector("#perchance-error-indicator").style.display = "none";
    __perchanceErrorString = "";
    document.querySelector("#perchance-error-stream").innerHTML = "";
    __currentPerchanceErrorCount = 0;
  }
  function __showPerchanceErrorBox() {
    document.querySelector("#perchance-error-stream").innerHTML = __perchanceErrorString;

    // to override user styles on the page:
    document.querySelectorAll("#perchance-error-container *").forEach(el => {
      el.style.cssText += ";font-family:inherit;";
      if(!el.style.cssText.includes("color")) el.style.cssText += ";color:inherit;";
    });

    document.querySelector("#perchance-error-container").style.display = 'flex';
  }
  </script>
  
  <script>
  if(window.location.host === "null.perchance.org") { // only if this HTML file is hosted at null.perchance.org
    fetch(`https://perchance.org/api/countView?generatorName=${window.location.pathname.slice(1)}&isFromEmbed=1`, {mode:"no-cors"});
  }
  </script>

<script>
  (async function() {
    // Here we tell the server to update the cache if needed, and if it did, then we temporarily bust the cache using a query string.
    if(window.location.host === "null.perchance.org") { // only if this HTML file is hosted at null.perchance.org
      let imports = JSON.parse(decodeURI(document.querySelector("#imported-generator-names").textContent));
      if(imports.length === 0) return;
      let cacheAge = await fetch(window.location.href, {method:"head"}).then(r => r.headers.get("age"));
      if(cacheAge === null) return;
      console.log(`${window.location.href} cache is ${cacheAge} seconds old.`);
      let cacheTime = Date.now() - Number(cacheAge)*1000; // this is UTC time, so it's okay to send to server
      let needToBustCache = await fetch(`https://perchance.org/api/clearCacheIfImportsHaveBeenUpdated?generatorName=${window.location.pathname.slice(1)}&importedGeneratorNames=${imports.join(",")}&cacheTime=${cacheTime}`).then(r => r.json());
      if(needToBustCache) {
        window.location.href = window.location.href.split("?")[0] + `?cacheBustDueToImportsHavingBeenEdited=${Math.random()}` + (window.location.href.split("?")[1] ? "&"+window.location.href.split("?")[1] : "");
      }
    }
  })();
</script>




</body></html>